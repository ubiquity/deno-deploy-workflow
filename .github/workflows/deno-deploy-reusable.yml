name: Reusable - Deno Deploy

on:
  workflow_call:
    inputs:
      project:
        description: Optional Deno Deploy project name for production (defaults to derived from repository name)
        required: false
        type: string
        default: ""
      preview_project:
        description: Optional preview project name (defaults to "preview-<project>")
        required: false
        type: string
        default: ""
      entrypoint:
        description: Entrypoint file passed to deployctl (relative to root)
        required: true
        type: string
      root:
        description: Directory to deploy from
        required: false
        type: string
        default: "."
      deno_version:
        description: Deno version range
        required: false
        type: string
        default: v2.x
      deployctl_version:
        description: deployctl version to install
        required: false
        type: string
        default: "1.12.0"
      install_command:
        description: Optional install command (multi-line allowed)
        required: false
        type: string
        default: ""
      build_command:
        description: Optional build command (multi-line allowed)
        required: false
        type: string
        default: ""
      node_version:
        description: Set to install Node.js (empty to skip)
        required: false
        type: string
        default: ""
      bun_version:
        description: Set to install Bun (empty to skip)
        required: false
        type: string
        default: ""
      include:
        description: Newline-separated include globs for deployctl
        required: false
        type: string
        default: ""
      exclude:
        description: Newline-separated exclude globs for deployctl
        required: false
        type: string
        default: |
          .git
          .github
          node_modules
          dist
          build
          coverage
          .turbo
          .next
          .vercel
      env_var_keys:
        description: Newline-separated env var names to forward as --env-var
        required: false
        type: string
        default: ""
      runtime_env:
        description: Newline-separated KEY=VALUE lines to forward as --env-var (preferred)
        required: false
        type: string
        default: ""
      build_env:
        description: Newline-separated KEY=VALUE lines to export before install/build
        required: false
        type: string
        default: ""
      ensure_project:
        description: Ensure the target project exists via Deno Deploy API before deploying
        required: false
        type: boolean
        default: true
      project_secrets:
        description: Newline-separated SECRET_NAME=ENV_VAR mappings to persist as Deno Deploy secrets (production and fallback)
        required: false
        type: string
        default: ""
      preview_project_secrets:
        description: Optional SECRET_NAME=ENV_VAR mappings for preview deployments (overrides project_secrets)
        required: false
        type: string
        default: ""
      required_env:
        description: Newline-separated env vars that must be present to deploy
        required: false
        type: string
        default: |
          DENO_DEPLOY_TOKEN
      submodules:
        description: Submodules checkout mode (empty to skip, 'recursive' for recursive)
        required: false
        type: string
        default: ""
      verify_url:
        description: Probe the deployed URL after deploy
        required: false
        type: boolean
        default: true
      index_html_path:
        description: Path to index.html for extracting static asset paths (relative to root)
        required: false
        type: string
        default: ""
      extra_paths:
        description: Optional newline-separated additional paths to test (e.g., API endpoints)
        required: false
        type: string
        default: ""
      debug_fetch_paths:
        description: Optional newline-separated URLs or paths (relative to deployed base URL) to GET after deploy for debugging (overrides dynamic extraction)
        required: false
        type: string
        default: ""
      debug_fetch_fail:
        description: Fail the workflow if any debug fetch returns a non-2xx/3xx status
        required: false
        type: boolean
        default: false
      create_preview:
        description: Create preview project when missing
        required: false
        type: boolean
        default: true
      prod_branch:
        description: Branch name for production deployments
        required: false
        type: string
        default: ""
    secrets:
      DENO_DEPLOY_TOKEN:
        required: true
      SUPABASE_URL:
        required: false
      SUPABASE_ANON_KEY:
        required: false
      DENO_PROJECT_SECRETS:
        required: false
      DENO_PREVIEW_PROJECT_SECRETS:
        required: false

permissions:
  contents: read
  id-token: write

jobs:
  deploy:
    name: Deno Deploy
    runs-on: ubuntu-22.04
    timeout-minutes: 360
    concurrency:
      group: deno-deploy-${{ inputs.project }}-${{ github.ref }}
      cancel-in-progress: true
    env:
      PROD_BRANCH: ${{ inputs.prod_branch != '' && inputs.prod_branch || github.event.repository.default_branch }}
      PROJECT: ${{ inputs.project }}
      PREVIEW_PROJECT: ${{ inputs.preview_project }}
      ENTRYPOINT: ${{ inputs.entrypoint }}
      ROOT_DIR: ${{ inputs.root }}
      INCLUDE: ${{ inputs.include }}
      EXCLUDE: ${{ inputs.exclude }}
      RUNTIME_ENV_KEYS: ${{ inputs.env_var_keys }}
      RUNTIME_ENV: ${{ inputs.runtime_env }}
      BUILD_ENV: ${{ inputs.build_env }}
      ENSURE_PROJECT: ${{ inputs.ensure_project }}
      PROJECT_SECRETS: ${{ inputs.project_secrets != '' && inputs.project_secrets || secrets.DENO_PROJECT_SECRETS || '' }}
      PREVIEW_PROJECT_SECRETS: ${{ inputs.preview_project_secrets != '' && inputs.preview_project_secrets || secrets.DENO_PREVIEW_PROJECT_SECRETS || '' }}
      REQUIRED_ENV: ${{ inputs.required_env }}
      BUILD_COMMAND: ${{ inputs.build_command }}
      INSTALL_COMMAND: ${{ inputs.install_command }}
      CREATE_PREVIEW: ${{ inputs.create_preview }}
      VERIFY_URL: ${{ inputs.verify_url }}
      INDEX_HTML_PATH: ${{ inputs.index_html_path }}
      EXTRA_PATHS: ${{ inputs.extra_paths }}
      DEBUG_FETCH_PATHS_INPUT: ${{ inputs.debug_fetch_paths }}
      DEBUG_FETCH_FAIL: ${{ inputs.debug_fetch_fail }}
      DENO_VERSION: ${{ inputs.deno_version }}
      DEPLOYCTL_VERSION: ${{ inputs.deployctl_version }}
      NODE_VERSION: ${{ inputs.node_version }}
      BUN_VERSION: ${{ inputs.bun_version }}
      DENO_DEPLOY_TOKEN: ${{ secrets.DENO_DEPLOY_TOKEN }}
      # Prefer org/global vars when present so shared values stay consistent across repos,
      # while still allowing repo-specific secrets to override.
      SUPABASE_URL: ${{ vars.SUPABASE_URL || secrets.SUPABASE_URL || '' }}
      SUPABASE_ANON_KEY: ${{ vars.SUPABASE_ANON_KEY || secrets.SUPABASE_ANON_KEY || '' }}
      NPM_CONFIG_REGISTRY: https://registry.npmjs.org

    steps:
      - name: Check out repository
        uses: actions/checkout@v4
        with:
          submodules: ${{ inputs.submodules }}

      - name: Set up Deno
        uses: denoland/setup-deno@v2
        with:
          deno-version: ${{ env.DENO_VERSION }}

      - name: Set up Node.js (optional)
        if: env.NODE_VERSION != ''
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: npm

      - name: Default Bun version (auto-detect)
        run: |
          set -euo pipefail
          if [ -n "${BUN_VERSION:-}" ]; then
            exit 0
          fi

          if printf '%s\n%s\n' "$INSTALL_COMMAND" "$BUILD_COMMAND" | grep -q 'bun '; then
            echo "BUN_VERSION=1.3.x" >> "$GITHUB_ENV"
            echo "Detected bun usage; defaulting BUN_VERSION=1.3.x"
          fi

      - name: Install Bun (optional)
        if: env.BUN_VERSION != ''
        run: |
          set -euo pipefail
          # Use the official install script to avoid setup-bun cache/download flakes.
          BUN_VERSION="${BUN_VERSION}" curl -fsSL https://bun.sh/install | bash
          echo "${HOME}/.bun/bin" >> "$GITHUB_PATH"

      - name: Show tool versions
        run: |
          set -euo pipefail
          deno --version
          if command -v node >/dev/null 2>&1; then node -v; fi
          if command -v bun >/dev/null 2>&1; then bun --version; fi

      - name: Install deployctl
        run: |
          set -euo pipefail
          deno install -gArf jsr:@deno/deployctl@${{ env.DEPLOYCTL_VERSION }}
          echo "${HOME}/.deno/bin" >> "$GITHUB_PATH"

      - name: Preflight (token and required env)
        id: preflight
        run: |
          set -euo pipefail
          missing=()
          while IFS= read -r key; do
            key=$(echo "$key" | tr -d '\r' | xargs)
            [ -z "$key" ] && continue
            if [ -z "${!key:-}" ]; then
              missing+=("$key")
            fi
          done <<< "$REQUIRED_ENV"

          if [ ${#missing[@]} -gt 0 ]; then
            echo "deploy=no" >> "$GITHUB_OUTPUT"
            {
              echo "### Deno Deploy"
              echo ""
              echo "- Skipped: missing env vars -> ${missing[*]}"
            } >> "$GITHUB_STEP_SUMMARY"
          else
            echo "deploy=yes" >> "$GITHUB_OUTPUT"
          fi

      - name: Determine target project
        if: steps.preflight.outputs.deploy == 'yes'
        id: target
        env:
          REF_NAME: ${{ github.ref_name }}
        run: |
          set -euo pipefail
          project="${PROJECT:-}"
          if [[ "$project" != *-ubq-fi ]]; then
            echo "::error::Project name must end with '-ubq-fi' to match router mapping. Got: $project"
            exit 1
          fi
          if [ ${#project} -gt 26 ]; then
            echo "::error::Base project name '${project}' exceeds 26 characters (Deno Deploy's max project name character limit)"
            exit 1
          fi

          preview="${PREVIEW_PROJECT:-}"
          if [ -z "$preview" ]; then
            base="${project%-ubq-fi}"
            # Clamp base to keep preview <=26 with prefix/suffix: p- + base + -ubq-fi
            if [ ${#base} -gt 17 ]; then
              # 12 chars + dash + 4-char hash = 17
              hash=$(printf '%s' "$base" | sha1sum | cut -c1-4)
              base="${base:0:12}-${hash}"
            fi
            preview="p-${base}-ubq-fi"
          fi

          if [ ${#preview} -gt 26 ]; then
            echo "::error::Preview project name '${preview}' exceeds 26 characters (Deno Deploy's max project name character limit)"
            exit 1
          fi

          mode="preview"
          target="$preview"
          if [ "$REF_NAME" = "$PROD_BRANCH" ]; then
            mode="production"
            target="$project"
          fi

          echo "mode=$mode" >> "$GITHUB_OUTPUT"
          echo "project=$target" >> "$GITHUB_OUTPUT"

      - name: Export build env
        if: steps.preflight.outputs.deploy == 'yes' && env.BUILD_ENV != ''
        run: |
          set -euo pipefail
          printf '%s\n' "$BUILD_ENV" | envsubst >> "$GITHUB_ENV"

      - name: Validate Supabase env
        if: steps.preflight.outputs.deploy == 'yes'
        run: |
          set -euo pipefail
          if [ -z "${SUPABASE_URL:-}" ] || [ -z "${SUPABASE_ANON_KEY:-}" ]; then
            echo "::error::Supabase env vars are required but missing (SUPABASE_URL/SUPABASE_ANON_KEY)"
            exit 1
          fi
          if ! printf '%s' "$SUPABASE_URL" | grep -Eq '^https?://'; then
            echo "::error::SUPABASE_URL must be an http(s) URL"
            exit 1
          fi

      - name: Install dependencies
        if: steps.preflight.outputs.deploy == 'yes' && env.INSTALL_COMMAND != ''
        run: |
          set -euo pipefail
          printf '%s\n' "$INSTALL_COMMAND" | bash

      - name: Build
        if: steps.preflight.outputs.deploy == 'yes' && env.BUILD_COMMAND != ''
        run: |
          set -euo pipefail
          printf '%s\n' "$BUILD_COMMAND" | bash

      - name: "Guard: unresolved env placeholders"
        if: steps.preflight.outputs.deploy == 'yes'
        run: |
          set -euo pipefail
          collect_keys() {
            awk '
              /^[A-Za-z_][A-Za-z0-9_]*=/ { sub(/=.*/, "", $0); print $0 }
              /^[A-Za-z_][A-Za-z0-9_]*$/ { print $0 }
            '
          }

          keys="$(
            {
              printf '%s\n' "$BUILD_ENV"
              printf '%s\n' "$RUNTIME_ENV"
              printf '%s\n' "$RUNTIME_ENV_KEYS"
              printf '%s\n' "$REQUIRED_ENV"
            } | collect_keys | sort -u
          )"

          # Fallback to Supabase keys if nothing parsed (should not happen)
          if [ -z "$keys" ]; then
            keys="SUPABASE_URL SUPABASE_ANON_KEY"
          fi

          search_terms=()
          for k in $keys; do
            search_terms+=("\$$k")
            search_terms+=("\${$k}")
          done

          candidate_dirs=(static dist out public frontend/dist build)
          matches=""

          for term in "${search_terms[@]}"; do
            for d in "${candidate_dirs[@]}"; do
              dir="${ROOT_DIR}/${d}"
              [ -d "$dir" ] || continue
              found=$(rg --no-config --fixed-strings --no-heading --line-number "$term" "$dir" || true)
              if [ -n "$found" ]; then
                matches+=$'\n'"${d}:"
                matches+=$'\n'"$found"
              fi
            done
          done

          if [ -n "$matches" ]; then
            echo "::error::Detected unresolved env placeholders in built assets. This usually means one of the expected env vars was empty when building. Populate the missing values (see below) and rerun."
            printf '%s\n' "$matches"
            exit 1
          fi

      - name: Resolve index.html path
        if: steps.preflight.outputs.deploy == 'yes'
        run: |
          set -euo pipefail
          requested="${INDEX_HTML_PATH:-}"
          index_file=""

          # Prefer explicit input when it exists
          if [ -n "$requested" ] && [ -f "${ROOT_DIR}/${requested}" ]; then
            index_file="${ROOT_DIR}/${requested}"
          elif [ -n "$requested" ]; then
            echo "::warning::Requested index_html_path '${requested}' not found under ${ROOT_DIR}"
          fi

          # Autodiscover common build outputs if not already resolved
          if [ -z "$index_file" ]; then
            for rel in \
              "static/index.html" \
              "public/index.html" \
              "frontend/dist/index.html" \
              "dist/index.html" \
              "out/index.html" \
              "src/client/dashboard/index.html" \
              "src/index.html" \
              "index.html"
            do
              if [ -f "${ROOT_DIR}/${rel}" ]; then
                index_file="${ROOT_DIR}/${rel}"
                break
              fi
            done
          fi

          # Final fallback: generic search, excluding heavy dirs
          if [ -z "$index_file" ]; then
            index_file=$(find "${ROOT_DIR}" \
              -maxdepth 5 \
              \( -path "*/node_modules/*" -o -path "*/.git/*" -o -path "*/.next/*" -o -path "*/.turbo/*" -o -path "*/.vercel/*" \) -prune \
              -o -name index.html -print | head -n 1 || true)
          fi

          if [ -n "$index_file" ]; then
            echo "INDEX_HTML_RESOLVED=${index_file}" >> "$GITHUB_ENV"
            echo "Using index.html at ${index_file}"
          else
            echo "INDEX_HTML_RESOLVED=" >> "$GITHUB_ENV"
            echo "::warning::No index.html found; debug fetch will only use extra/manual paths"
          fi

      - name: Build debug fetch paths
        if: steps.preflight.outputs.deploy == 'yes'
        run: |
          set -euo pipefail
          manual_paths="${DEBUG_FETCH_PATHS_INPUT:-}"
          index_file="${INDEX_HTML_RESOLVED:-}"
          paths="/"

          if [ -n "$index_file" ] && [ -f "$index_file" ]; then
            # Extract paths from href and src attributes (supports single and double quotes)
            extracted=$(grep -oE "href=([\"'])([^\"']*)\\1" "$index_file" | sed -E "s/href=([\"'])([^\"']*)\\1/\\2/" | grep -v '^http' | sed 's|^[^/]|/&|')
            extracted="$extracted"$'\n'$(grep -oE "src=([\"'])([^\"']*)\\1" "$index_file" | sed -E "s/src=([\"'])([^\"']*)\\1/\\2/" | grep -v '^http' | sed 's|^[^/]|/&|')
            paths="$paths"$'\n'"$extracted"
          elif [ -n "$index_file" ]; then
            echo "::warning::Index HTML not found at ${index_file}; debug fetch will use extras/manual paths only"
          fi

          if [ -n "$EXTRA_PATHS" ]; then
            paths="$paths"$'\n'"$EXTRA_PATHS"
          fi

          if [ -n "$manual_paths" ]; then
            paths="$paths"$'\n'"$manual_paths"
          fi

          paths=$(printf '%s\n' "$paths" | tr -d '\r' | while IFS= read -r p; do
            [ -z "$p" ] && continue
            case "$p" in
              http://*|https://*|//*) printf '%s\n' "$p" ;;
              /*) printf '%s\n' "$p" ;;
              *) printf '/%s\n' "$p" ;;
            esac
          done | sort -u | sed '/^$/d')

          {
            echo "DEBUG_FETCH_PATHS<<EOF"
            echo "$paths"
            echo "EOF"
          } >> "$GITHUB_ENV"

      - name: Ensure project exists and sync secrets
        if: steps.preflight.outputs.deploy == 'yes'
        env:
          MODE: ${{ steps.target.outputs.mode }}
          TARGET_PROJECT: ${{ steps.target.outputs.project }}
        run: |
          set -euo pipefail
          project="${TARGET_PROJECT:-}"
          mode="${MODE:-}"
          if [ -z "$project" ]; then
            echo "::error::Target project was not resolved"
            exit 1
          fi

          secrets_block="$PROJECT_SECRETS"
          if [ "$mode" = "preview" ] && [ -n "$PREVIEW_PROJECT_SECRETS" ]; then
            secrets_block="$PREVIEW_PROJECT_SECRETS"
          fi

          if [ "$ENSURE_PROJECT" != "true" ] && [ -z "$secrets_block" ]; then
            echo "Skipping project ensure/secret sync (disabled and no secrets provided)"
            exit 0
          fi

          api_base="https://dash.deno.com/api/projects"
          tmp_resp="$(mktemp)"
          http_code=$(curl -sS -o "$tmp_resp" -w "%{http_code}" \
            -H "Authorization: Bearer $DENO_DEPLOY_TOKEN" \
            "$api_base/$project" || echo "000")

          if [ "$http_code" = "404" ]; then
            if [ "$ENSURE_PROJECT" != "true" ]; then
              echo "::error::Project $project not found and ensure_project is false"
              cat "$tmp_resp" || true
              exit 1
            fi
            http_code=$(curl -sS -o "$tmp_resp" -w "%{http_code}" \
              -X POST "$api_base" \
              -H "Authorization: Bearer $DENO_DEPLOY_TOKEN" \
              -H "Content-Type: application/json" \
              -d "{\"name\":\"$project\"}" || echo "000")
            if [ "$http_code" -ge 300 ] || [ "$http_code" -lt 200 ]; then
              echo "::error::Failed to create project $project (HTTP $http_code)"
              cat "$tmp_resp" || true
              exit 1
            fi
            echo "Created project $project"
          elif [ "$http_code" != "200" ]; then
            echo "::error::Failed to fetch project $project (HTTP $http_code)"
            cat "$tmp_resp" || true
            exit 1
          fi
          rm -f "$tmp_resp"

          if [ -n "$secrets_block" ]; then
            while IFS= read -r line; do
              line=$(echo "$line" | tr -d '\r' | xargs)
              [ -z "$line" ] && continue
              if ! printf '%s\n' "$line" | grep -q '='; then
                echo "::warning::project_secrets line missing '=': $line"
                continue
              fi
              secret_name=${line%%=*}
              env_key=${line#*=}
              if [ -z "$secret_name" ] || [ -z "$env_key" ]; then
                echo "::warning::project_secrets line invalid: $line"
                continue
              fi
              val="${!env_key:-}"
              if [ -z "$val" ]; then
                echo "::warning::Secret $secret_name skipped because env $env_key is empty"
                continue
              fi
              echo "::add-mask::$val"
              tmp_secret="$(mktemp)"
              code=$(curl -sS -o "$tmp_secret" -w "%{http_code}" \
                -X POST "$api_base/$project/secrets" \
                -H "Authorization: Bearer $DENO_DEPLOY_TOKEN" \
                -H "Content-Type: application/json" \
                -d "{\"name\":\"$secret_name\",\"value\":\"$val\"}" || echo "000")
              if [ "$code" != "200" ]; then
                echo "::error::Failed to set secret $secret_name (HTTP $code)"
                cat "$tmp_secret" || true
                rm -f "$tmp_secret"
                exit 1
              fi
              rm -f "$tmp_secret"
            done <<< "$secrets_block"
          fi

      - name: Deploy to Deno Deploy
        if: steps.preflight.outputs.deploy == 'yes'
        id: deploy
        run: |
          set -euo pipefail
          mode='${{ steps.target.outputs.mode }}'
          target='${{ steps.target.outputs.project }}'

          flags=(
            "--project=$target"
            "--entrypoint=$ENTRYPOINT"
            "--root=$ROOT_DIR"
            "--token=$DENO_DEPLOY_TOKEN"
          )

          if [ "$mode" = "production" ]; then
            flags+=("--prod")
          elif [ "$CREATE_PREVIEW" = "true" ]; then
            flags+=("--create")
          fi

          # Always include entrypoint and deno.json so deployctl finds the server.
          flags+=("--include=$ENTRYPOINT")
          if [ -f "deno.json" ]; then
            flags+=("--include=deno.json")
          fi

          while IFS= read -r inc; do
            inc=$(echo "$inc" | tr -d '\r' | xargs)
            [ -z "$inc" ] && continue
            flags+=("--include=$inc")
          done <<< "$INCLUDE"

          while IFS= read -r exc; do
            exc=$(echo "$exc" | tr -d '\r' | xargs)
            [ -z "$exc" ] && continue
            flags+=("--exclude=$exc")
          done <<< "$EXCLUDE"

          while IFS= read -r key; do
            key=$(echo "$key" | tr -d '\r' | xargs)
            [ -z "$key" ] && continue
            val="${!key:-}"
            if [ -n "$val" ]; then
              flags+=("--env-var=${key}=${val}")
            else
              echo "::warning::Requested env $key for deploy but it is empty"
            fi
          done <<< "$RUNTIME_ENV_KEYS"

          while IFS= read -r line; do
            line=$(echo "$line" | tr -d '\r')
            [ -z "$line" ] && continue
            if ! printf '%s\n' "$line" | grep -q '='; then
              echo "::warning::runtime_env line missing '=': $line"
              continue
            fi
            flags+=("--env-var=$line")
          done <<< "$RUNTIME_ENV"

          attempt=1
          poll_sleep=60
          start_time=$(date +%s)
          # Leave a small buffer so verify/summary steps can complete before hitting the 6h Actions limit.
          max_seconds=$(( 6 * 60 * 60 - 300 ))
          while true; do
            set +e
            output=$(deployctl deploy "${flags[@]}" 2>&1)
            status=$?
            set -e
            if [ $status -eq 0 ]; then
              echo "$output"
              break
            fi
            if echo "$output" | grep -q "Too many deployments created per hour"; then
              now=$(date +%s)
              elapsed=$(( now - start_time ))
              remaining=$(( max_seconds - elapsed ))
              if [ $remaining -le 0 ]; then
                echo "::error::Deno Deploy rate limit persisted for ~${elapsed}s; exhausted retry window (6h budget)"
                echo "$output"
                exit 1
              fi
              sleep_for=$poll_sleep
              if [ $sleep_for -gt $remaining ]; then
                sleep_for=$remaining
              fi
              echo "::warning::Deno Deploy rate limit (attempt ${attempt}); sleeping ${sleep_for}s (elapsed ${elapsed}s, remaining ${remaining}s)"
              sleep "$sleep_for"
              attempt=$(( attempt + 1 ))
              continue
            fi
            echo "$output"
            exit $status
          done

          echo "project=$target" >> "$GITHUB_OUTPUT"
          echo "mode=$mode" >> "$GITHUB_OUTPUT"

      - name: Determine deployed URL
        if: steps.preflight.outputs.deploy == 'yes' && env.VERIFY_URL == 'true'
        id: deployed_url
        run: |
          set -euo pipefail
          project="${{ steps.deploy.outputs.project }}"
          fallback="https://${project}.deno.dev"
          resp=$(curl -sS -H "Authorization: Bearer $DENO_DEPLOY_TOKEN" "https://dash.deno.com/api/projects/${project}" || true)
          URL=$(PROJECT="$project" FALLBACK="$fallback" RESP="$resp" cat <<'PY' | sed 's/^  //' | python -
            import json, os, sys

            resp = os.environ.get("RESP", "")
            fallback = os.environ.get("FALLBACK", "")
            url = fallback
            try:
                data = json.loads(resp or "{}")
                domains = data.get("domains") or []
                if isinstance(domains, list) and domains:
                    dom = domains[0]
                    if isinstance(dom, dict):
                        dom = dom.get("domain") or dom.get("name") or ""
                    if dom:
                        url = f"https://{dom}"
            except Exception as exc:  # noqa: BLE001
                sys.stderr.write(f"Warning: failed to parse project domains: {exc}\n")
            print(url, end="")
          PY
          )
          if [ -z "$URL" ]; then
            URL="$fallback"
          fi
          echo "url=$URL" >> "$GITHUB_OUTPUT"

      - name: Verify deployment
        if: steps.preflight.outputs.deploy == 'yes' && env.VERIFY_URL == 'true'
        id: verify
        continue-on-error: true
        run: |
          set -euo pipefail
          url='${{ steps.deployed_url.outputs.url }}'
          if [ -z "$url" ]; then
            url="https://${{ steps.deploy.outputs.project }}.deno.dev"
          fi
          codes_ok="200"
          status="fail"
          http_code="000"
          for _ in 1 2 3; do
            http_code=$(curl -sS -L -o /dev/null -w "%{http_code}" "$url" || echo "000")
            if echo "$codes_ok" | grep -q "\b$http_code\b"; then
              status="ok"
              break
            fi
            sleep 5
          done
          echo "http_code=$http_code" >> "$GITHUB_OUTPUT"
          echo "status=$status" >> "$GITHUB_OUTPUT"
          if [ "$status" != "ok" ]; then
            echo "::error::Deployment probe returned HTTP $http_code at $url"
          fi

      - name: Debug fetch paths (optional)
        if: steps.preflight.outputs.deploy == 'yes' && env.DEBUG_FETCH_PATHS != ''
        run: |
          set -euo pipefail
          base='${{ steps.deployed_url.outputs.url }}'
          if [ -z "$base" ]; then
            base="https://${{ steps.deploy.outputs.project }}.deno.dev"
          fi
          ok_codes="200 301 302 304 308"
          misses=()
          summary=""

          while IFS= read -r raw; do
            raw=$(echo "$raw" | tr -d '\r' | xargs)
            [ -z "$raw" ] && continue
            case "$raw" in
              http://*|https://*) url="$raw" ;;
              /*) url="${base%/}$raw" ;;
              *) url="${base%/}/$raw" ;;
            esac
            http_code=$(curl -sS -o /dev/null -w "%{http_code}" "$url" || echo "000")
            if echo "$ok_codes" | grep -q "\b$http_code\b"; then
              summary+="- [ok] $url (HTTP $http_code)\n"
            else
              summary+="- [miss] $url (HTTP $http_code)\n"
              misses+=("$url")
            fi
          done <<< "$DEBUG_FETCH_PATHS"

          {
            echo "### Debug fetch"
            echo ""
            printf "%b" "$summary"
          } >> "$GITHUB_STEP_SUMMARY"

          if [ ${#misses[@]} -gt 0 ] && [ "${DEBUG_FETCH_FAIL:-false}" = "true" ]; then
            echo "::error::Debug fetch failures: ${misses[*]}"
            exit 1
          fi

      - name: Summary
        if: steps.preflight.outputs.deploy == 'yes'
        run: |
          mode='${{ steps.deploy.outputs.mode }}'
          project='${{ steps.deploy.outputs.project }}'
          url="${{ steps.deployed_url.outputs.url || '' }}"
          http="${{ steps.verify.outputs.http_code || '' }}"
          status="${{ steps.verify.outputs.status || '' }}"
          {
            echo "### Deno Deploy"
            echo ""
            echo "- Mode: ${mode:-unknown}"
            echo "- Project: ${project}"
            if [ -n "$url" ]; then
              echo "- URL: ${url}"
            fi
            if [ -n "$http" ]; then
              echo "- HTTP: ${http} (${status})"
            fi
            echo "- Ref: ${GITHUB_REF##*/}"
          } >> "$GITHUB_STEP_SUMMARY"

      - name: Fail on probe failure
        if: steps.preflight.outputs.deploy == 'yes' && env.VERIFY_URL == 'true'
        run: |
          status='${{ steps.verify.outputs.status || '' }}'
          http='${{ steps.verify.outputs.http_code || '' }}'
          url='${{ steps.deployed_url.outputs.url || '' }}'
          if [ "$status" != "ok" ]; then
            echo "::error::Deployment probe failed with HTTP ${http:-unknown} at ${url:-<missing url>}"
            exit 1
          fi
