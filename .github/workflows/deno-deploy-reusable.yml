name: Reusable - Deno Deploy

on:
  workflow_call:
    inputs:
      project:
        description: Optional Deno Deploy project name for production (defaults to derived from repository name)
        required: false
        type: string
        default: ""
      preview_project:
        description: Optional preview project name (defaults to "preview-<project>")
        required: false
        type: string
        default: ""
      entrypoint:
        description: Entrypoint file passed to deployctl (relative to root)
        required: true
        type: string
      root:
        description: Directory to deploy from
        required: false
        type: string
        default: "."
      deno_version:
        description: Deno version range
        required: false
        type: string
        default: v2.x
      deployctl_version:
        description: deployctl version to install
        required: false
        type: string
        default: "1.12.0"
      install_command:
        description: Optional install command (multi-line allowed)
        required: false
        type: string
        default: ""
      build_command:
        description: Optional build command (multi-line allowed)
        required: false
        type: string
        default: ""
      node_version:
        description: Set to install Node.js (empty to skip)
        required: false
        type: string
        default: ""
      bun_version:
        description: Set to install Bun (empty to skip)
        required: false
        type: string
        default: ""
      include:
        description: Newline-separated include globs for deployctl
        required: false
        type: string
        default: ""
      exclude:
        description: Newline-separated exclude globs for deployctl
        required: false
        type: string
        default: |
          .git
          .github
          node_modules
          dist
          build
          coverage
          .turbo
          .next
          .vercel
      env_var_keys:
        description: Newline-separated env var names to forward as --env-var
        required: false
        type: string
        default: ""
      runtime_env:
        description: Newline-separated KEY=VALUE lines to forward as --env-var (preferred)
        required: false
        type: string
        default: ""
      build_env:
        description: Newline-separated KEY=VALUE lines to export before install/build
        required: false
        type: string
        default: ""
      forward_all_secrets:
        description: Forward all available GitHub secrets as runtime env vars (dangerous; opt-in)
        required: false
        type: boolean
        default: false
      forward_all_secrets_exclude:
        description: Newline-separated secret names to exclude when forward_all_secrets is true
        required: false
        type: string
        default: |
          DENO_DEPLOY_TOKEN
          GITHUB_TOKEN
      ensure_project:
        description: Ensure the target project exists via Deno Deploy API before deploying
        required: false
        type: boolean
        default: true
      project_secrets:
        description: Newline-separated SECRET_NAME=ENV_VAR mappings to persist as Deno Deploy secrets (production and fallback)
        required: false
        type: string
        default: ""
      preview_project_secrets:
        description: Optional SECRET_NAME=ENV_VAR mappings for preview deployments (overrides project_secrets)
        required: false
        type: string
        default: ""
      required_env:
        description: Newline-separated env vars that must be present to deploy
        required: false
        type: string
        default: |
          DENO_DEPLOY_TOKEN
      submodules:
        description: Submodules checkout mode (empty to skip, 'recursive' for recursive)
        required: false
        type: string
        default: ""
      verify_url:
        description: Probe the deployed URL after deploy
        required: false
        type: boolean
        default: true
      index_html_path:
        description: Path to index.html for extracting static asset paths (relative to root)
        required: false
        type: string
        default: ""
      extra_paths:
        description: Optional newline-separated additional paths to test (e.g., API endpoints)
        required: false
        type: string
        default: ""
      debug_fetch_paths:
        description: Optional newline-separated URLs or paths (relative to deployed base URL) to GET after deploy for debugging (overrides dynamic extraction)
        required: false
        type: string
        default: ""
      debug_fetch_fail:
        description: Fail the workflow if any debug fetch returns a non-2xx/3xx status
        required: false
        type: boolean
        default: false
      create_preview:
        description: Create preview project when missing
        required: false
        type: boolean
        default: true
      comment_pr:
        description: Post/update a deployment comment on pull requests
        required: false
        type: boolean
        default: true
      prod_branch:
        description: Branch name for production deployments
        required: false
        type: string
        default: ""
    secrets:
      DENO_DEPLOY_TOKEN:
        required: true
      SUPABASE_URL:
        required: false
      SUPABASE_ANON_KEY:
        required: false
      SUPABASE_SERVICE_ROLE_KEY:
        required: false
      DENO_PROJECT_SECRETS:
        required: false
      DENO_PREVIEW_PROJECT_SECRETS:
        required: false

permissions:
  contents: read
  issues: write
  pull-requests: write

jobs:
  deploy:
    name: Deno Deploy
    runs-on: ubuntu-22.04
    timeout-minutes: 360
    concurrency:
      group: deno-deploy-${{ inputs.project }}-${{ github.ref }}
      cancel-in-progress: true
    env:
      PROD_BRANCH: ${{ inputs.prod_branch != '' && inputs.prod_branch || github.event.repository.default_branch }}
      PROJECT: ${{ inputs.project }}
      PREVIEW_PROJECT: ${{ inputs.preview_project }}
      ENTRYPOINT: ${{ inputs.entrypoint }}
      ROOT_DIR: ${{ inputs.root }}
      INCLUDE: ${{ inputs.include }}
      EXCLUDE: ${{ inputs.exclude }}
      RUNTIME_ENV_KEYS: ${{ inputs.env_var_keys }}
      RUNTIME_ENV: ${{ inputs.runtime_env }}
      BUILD_ENV: ${{ inputs.build_env }}
      FORWARD_ALL_SECRETS: ${{ inputs.forward_all_secrets }}
      FORWARD_ALL_SECRETS_EXCLUDE: ${{ inputs.forward_all_secrets_exclude }}
      ENSURE_PROJECT: ${{ inputs.ensure_project }}
      PROJECT_SECRETS: ${{ inputs.project_secrets != '' && inputs.project_secrets || secrets.DENO_PROJECT_SECRETS || '' }}
      PREVIEW_PROJECT_SECRETS: ${{ inputs.preview_project_secrets != '' && inputs.preview_project_secrets || secrets.DENO_PREVIEW_PROJECT_SECRETS || '' }}
      REQUIRED_ENV: ${{ inputs.required_env }}
      BUILD_COMMAND: ${{ inputs.build_command }}
      INSTALL_COMMAND: ${{ inputs.install_command }}
      CREATE_PREVIEW: ${{ inputs.create_preview }}
      VERIFY_URL: ${{ inputs.verify_url }}
      COMMENT_PR: ${{ inputs.comment_pr }}
      INDEX_HTML_PATH: ${{ inputs.index_html_path }}
      EXTRA_PATHS: ${{ inputs.extra_paths }}
      DEBUG_FETCH_PATHS_INPUT: ${{ inputs.debug_fetch_paths }}
      DEBUG_FETCH_FAIL: ${{ inputs.debug_fetch_fail }}
      DENO_VERSION: ${{ inputs.deno_version }}
      DEPLOYCTL_VERSION: ${{ inputs.deployctl_version }}
      NODE_VERSION: ${{ inputs.node_version }}
      BUN_VERSION: ${{ inputs.bun_version }}
      DENO_DEPLOY_TOKEN: ${{ secrets.DENO_DEPLOY_TOKEN }}
      # Prefer org/global vars when present so shared values stay consistent across repos,
      # while still allowing repo-specific secrets to override.
      SUPABASE_URL: ${{ vars.SUPABASE_URL || secrets.SUPABASE_URL || '' }}
      SUPABASE_ANON_KEY: ${{ vars.SUPABASE_ANON_KEY || secrets.SUPABASE_ANON_KEY || '' }}
      SUPABASE_SERVICE_ROLE_KEY: ${{ vars.SUPABASE_SERVICE_ROLE_KEY || secrets.SUPABASE_SERVICE_ROLE_KEY || '' }}
      NPM_CONFIG_REGISTRY: https://registry.npmjs.org

    steps:
      - name: Check out repository
        uses: actions/checkout@v4
        with:
          submodules: ${{ inputs.submodules }}

      - name: Set up Deno
        uses: denoland/setup-deno@v2
        with:
          deno-version: ${{ env.DENO_VERSION }}

      - name: Set up Node.js (optional)
        if: env.NODE_VERSION != ''
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: npm

      - name: Default Bun version (auto-detect)
        run: |
          set -euo pipefail
          if [ -n "${BUN_VERSION:-}" ]; then
            exit 0
          fi

          if printf '%s\n%s\n' "$INSTALL_COMMAND" "$BUILD_COMMAND" | grep -q 'bun '; then
            echo "BUN_VERSION=1.3.x" >> "$GITHUB_ENV"
            echo "Detected bun usage; defaulting BUN_VERSION=1.3.x"
          fi

      - name: Install Bun (optional)
        if: env.BUN_VERSION != ''
        run: |
          set -euo pipefail
          # Use the official install script to avoid setup-bun cache/download flakes.
          BUN_VERSION="${BUN_VERSION}" curl -fsSL https://bun.sh/install | bash
          echo "${HOME}/.bun/bin" >> "$GITHUB_PATH"

      - name: Show tool versions
        run: |
          set -euo pipefail
          deno --version
          if command -v node >/dev/null 2>&1; then node -v; fi
          if command -v bun >/dev/null 2>&1; then bun --version; fi

      - name: Install deployctl
        run: |
          set -euo pipefail
          deno install -gArf jsr:@deno/deployctl@${{ env.DEPLOYCTL_VERSION }}
          echo "${HOME}/.deno/bin" >> "$GITHUB_PATH"

      - name: Preflight (token and required env)
        id: preflight
        run: |
          set -euo pipefail
          missing=()
          while IFS= read -r key; do
            key=$(echo "$key" | tr -d '\r' | xargs)
            [ -z "$key" ] && continue
            if [ -z "${!key:-}" ]; then
              missing+=("$key")
            fi
          done <<< "$REQUIRED_ENV"

          if [ ${#missing[@]} -gt 0 ]; then
            echo "deploy=no" >> "$GITHUB_OUTPUT"
            {
              echo "### Deno Deploy"
              echo ""
              echo "- Skipped: missing env vars -> ${missing[*]}"
            } >> "$GITHUB_STEP_SUMMARY"
          else
            echo "deploy=yes" >> "$GITHUB_OUTPUT"
          fi

      - name: Determine target project
        if: steps.preflight.outputs.deploy == 'yes'
        id: target
        env:
          REF_NAME: ${{ github.ref_name }}
        run: |
          set -euo pipefail
          project="${PROJECT:-}"
          if [[ "$project" != *-ubq-fi ]]; then
            echo "::error::Project name must end with '-ubq-fi' to match router mapping. Got: $project"
            exit 1
          fi
          if [ ${#project} -gt 26 ]; then
            echo "::error::Base project name '${project}' exceeds 26 characters (Deno Deploy's max project name character limit)"
            exit 1
          fi

          preview="${PREVIEW_PROJECT:-}"
          if [ -z "$preview" ]; then
            base="${project%-ubq-fi}"
            # Clamp base to keep preview <=26 with prefix/suffix: p- + base + -ubq-fi
            if [ ${#base} -gt 17 ]; then
              # 12 chars + dash + 4-char hash = 17
              hash=$(printf '%s' "$base" | sha1sum | cut -c1-4)
              base="${base:0:12}-${hash}"
            fi
            preview="p-${base}-ubq-fi"
          fi

          if [ ${#preview} -gt 26 ]; then
            echo "::error::Preview project name '${preview}' exceeds 26 characters (Deno Deploy's max project name character limit)"
            exit 1
          fi

          mode="preview"
          target="$preview"
          if [ "$REF_NAME" = "$PROD_BRANCH" ]; then
            mode="production"
            target="$project"
          fi

          echo "mode=$mode" >> "$GITHUB_OUTPUT"
          echo "project=$target" >> "$GITHUB_OUTPUT"

      - name: Export build env
        if: steps.preflight.outputs.deploy == 'yes' && env.BUILD_ENV != ''
        run: |
          set -euo pipefail
          printf '%s\n' "$BUILD_ENV" | envsubst >> "$GITHUB_ENV"

      - name: Validate Supabase env
        if: steps.preflight.outputs.deploy == 'yes'
        run: |
          set -euo pipefail
          if [ -z "${SUPABASE_URL:-}" ] || [ -z "${SUPABASE_ANON_KEY:-}" ]; then
            echo "::error::Supabase env vars are required but missing (SUPABASE_URL/SUPABASE_ANON_KEY)"
            exit 1
          fi
          if ! printf '%s' "$SUPABASE_URL" | grep -Eq '^https?://'; then
            echo "::error::SUPABASE_URL must be an http(s) URL"
            exit 1
          fi

      - name: Install dependencies
        if: steps.preflight.outputs.deploy == 'yes' && env.INSTALL_COMMAND != ''
        run: |
          set -euo pipefail
          printf '%s\n' "$INSTALL_COMMAND" | bash

      - name: Build
        if: steps.preflight.outputs.deploy == 'yes' && env.BUILD_COMMAND != ''
        run: |
          set -euo pipefail
          printf '%s\n' "$BUILD_COMMAND" | bash

      - name: "Guard: unresolved env placeholders"
        if: steps.preflight.outputs.deploy == 'yes'
        run: |
          set -euo pipefail
          collect_keys() {
            awk '
              /^[A-Za-z_][A-Za-z0-9_]*=/ { sub(/=.*/, "", $0); print $0 }
              /^[A-Za-z_][A-Za-z0-9_]*$/ { print $0 }
            '
          }

          keys="$(
            {
              printf '%s\n' "$BUILD_ENV"
              printf '%s\n' "$RUNTIME_ENV"
              printf '%s\n' "$RUNTIME_ENV_KEYS"
              printf '%s\n' "$REQUIRED_ENV"
            } | collect_keys | sort -u
          )"

          # Fallback to Supabase keys if nothing parsed (should not happen)
          if [ -z "$keys" ]; then
            keys="SUPABASE_URL SUPABASE_ANON_KEY"
          fi

          search_terms=()
          for k in $keys; do
            search_terms+=("\$$k")
            search_terms+=("\${$k}")
          done

          candidate_dirs=(static dist out public frontend/dist build)
          matches=""

          for term in "${search_terms[@]}"; do
            for d in "${candidate_dirs[@]}"; do
              dir="${ROOT_DIR}/${d}"
              [ -d "$dir" ] || continue
              found=$(rg --no-config --fixed-strings --no-heading --line-number "$term" "$dir" || true)
              if [ -n "$found" ]; then
                matches+=$'\n'"${d}:"
                matches+=$'\n'"$found"
              fi
            done
          done

          if [ -n "$matches" ]; then
            echo "::error::Detected unresolved env placeholders in built assets. This usually means one of the expected env vars was empty when building. Populate the missing values (see below) and rerun."
            printf '%s\n' "$matches"
            exit 1
          fi

      - name: Resolve index.html path
        if: steps.preflight.outputs.deploy == 'yes'
        run: |
          set -euo pipefail
          requested="${INDEX_HTML_PATH:-}"
          index_file=""

          # Prefer explicit input when it exists
          if [ -n "$requested" ] && [ -f "${ROOT_DIR}/${requested}" ]; then
            index_file="${ROOT_DIR}/${requested}"
          elif [ -n "$requested" ]; then
            echo "::warning::Requested index_html_path '${requested}' not found under ${ROOT_DIR}"
          fi

          # Autodiscover common build outputs if not already resolved
          if [ -z "$index_file" ]; then
            for rel in \
              "static/index.html" \
              "public/index.html" \
              "frontend/dist/index.html" \
              "dist/index.html" \
              "out/index.html" \
              "src/client/dashboard/index.html" \
              "src/index.html" \
              "index.html"
            do
              if [ -f "${ROOT_DIR}/${rel}" ]; then
                index_file="${ROOT_DIR}/${rel}"
                break
              fi
            done
          fi

          # Final fallback: generic search, excluding heavy dirs
          if [ -z "$index_file" ]; then
            index_file=$(find "${ROOT_DIR}" \
              -maxdepth 5 \
              \( -path "*/node_modules/*" -o -path "*/.git/*" -o -path "*/.next/*" -o -path "*/.turbo/*" -o -path "*/.vercel/*" \) -prune \
              -o -name index.html -print | head -n 1 || true)
          fi

          if [ -n "$index_file" ]; then
            echo "INDEX_HTML_RESOLVED=${index_file}" >> "$GITHUB_ENV"
            echo "Using index.html at ${index_file}"
          else
            echo "INDEX_HTML_RESOLVED=" >> "$GITHUB_ENV"
            echo "::warning::No index.html found; debug fetch will only use extra/manual paths"
          fi

      - name: Build debug fetch paths
        if: steps.preflight.outputs.deploy == 'yes'
        run: |
          set -euo pipefail
          manual_paths="${DEBUG_FETCH_PATHS_INPUT:-}"
          index_file="${INDEX_HTML_RESOLVED:-}"
          paths="/"

          if [ -n "$index_file" ] && [ -f "$index_file" ]; then
            # Extract paths from href and src attributes (supports single and double quotes)
            extracted=$(grep -oE "href=([\"'])([^\"']*)\\1" "$index_file" | sed -E "s/href=([\"'])([^\"']*)\\1/\\2/" | grep -v '^http' | sed 's|^[^/]|/&|')
            extracted="$extracted"$'\n'$(grep -oE "src=([\"'])([^\"']*)\\1" "$index_file" | sed -E "s/src=([\"'])([^\"']*)\\1/\\2/" | grep -v '^http' | sed 's|^[^/]|/&|')
            paths="$paths"$'\n'"$extracted"
          elif [ -n "$index_file" ]; then
            echo "::warning::Index HTML not found at ${index_file}; debug fetch will use extras/manual paths only"
          fi

          if [ -n "$EXTRA_PATHS" ]; then
            paths="$paths"$'\n'"$EXTRA_PATHS"
          fi

          if [ -n "$manual_paths" ]; then
            paths="$paths"$'\n'"$manual_paths"
          fi

          paths=$(printf '%s\n' "$paths" | tr -d '\r' | while IFS= read -r p; do
            [ -z "$p" ] && continue
            case "$p" in
              http://*|https://*|//*) printf '%s\n' "$p" ;;
              /*) printf '%s\n' "$p" ;;
              *) printf '/%s\n' "$p" ;;
            esac
          done | sort -u | sed '/^$/d')

          {
            echo "DEBUG_FETCH_PATHS<<EOF"
            echo "$paths"
            echo "EOF"
          } >> "$GITHUB_ENV"

      - name: Forward all GitHub secrets (runtime)
        if: steps.preflight.outputs.deploy == 'yes' && env.FORWARD_ALL_SECRETS == 'true'
        env:
          ALL_SECRETS_JSON: ${{ toJson(secrets) }}
        run: |
          set -euo pipefail

          tmp_out="$(mktemp)"
          python - <<'PY' > "$tmp_out"
          import json, os, re, sys

          raw = os.environ.get("ALL_SECRETS_JSON", "") or "{}"
          try:
              data = json.loads(raw)
          except Exception:
              data = {}

          exclude = {
              k.strip()
              for k in (os.environ.get("FORWARD_ALL_SECRETS_EXCLUDE", "") or "").splitlines()
              if k.strip()
          }
          valid = re.compile(r"^[A-Za-z_][A-Za-z0-9_]*$")

          lines = []
          for k, v in data.items():
              if k in exclude:
                  continue
              if not valid.match(k):
                  continue
              if v is None:
                  continue
              v = str(v)
              if not v:
                  continue
              if "\n" in v or "\r" in v:
                  continue
              lines.append(f"{k}={v}")

          sys.stdout.write("\n".join(lines))
          PY

          extra_runtime="$(cat "$tmp_out")"
          rm -f "$tmp_out"
          [ -z "$extra_runtime" ] && exit 0

          while IFS= read -r line; do
            [ -z "$line" ] && continue
            echo "::add-mask::${line#*=}"
          done <<< "$extra_runtime"

          combined="$(printf '%s\n' "$RUNTIME_ENV" "$extra_runtime" | tr -d '\r' | sed '/^$/d')"
          {
            echo "RUNTIME_ENV<<EOF"
            echo "$combined"
            echo "EOF"
          } >> "$GITHUB_ENV"

      - name: Ensure project exists and sync secrets
        if: steps.preflight.outputs.deploy == 'yes'
        env:
          MODE: ${{ steps.target.outputs.mode }}
          TARGET_PROJECT: ${{ steps.target.outputs.project }}
        run: |
          set -euo pipefail
          project="${TARGET_PROJECT:-}"
          mode="${MODE:-}"
          if [ -z "$project" ]; then
            echo "::error::Target project was not resolved"
            exit 1
          fi

          secrets_block="$PROJECT_SECRETS"
          if [ "$mode" = "preview" ] && [ -n "$PREVIEW_PROJECT_SECRETS" ]; then
            secrets_block="$PREVIEW_PROJECT_SECRETS"
          fi

          if [ "$ENSURE_PROJECT" != "true" ] && [ -z "$secrets_block" ]; then
            echo "Skipping project ensure/secret sync (disabled and no secrets provided)"
            exit 0
          fi

          api_base="https://dash.deno.com/api/projects"
          tmp_resp="$(mktemp)"
          http_code=$(curl -sS -o "$tmp_resp" -w "%{http_code}" \
            -H "Authorization: Bearer $DENO_DEPLOY_TOKEN" \
            "$api_base/$project" || echo "000")

          if [ "$http_code" = "404" ]; then
            if [ "$ENSURE_PROJECT" != "true" ]; then
              echo "::error::Project $project not found and ensure_project is false"
              cat "$tmp_resp" || true
              exit 1
            fi
            http_code=$(curl -sS -o "$tmp_resp" -w "%{http_code}" \
              -X POST "$api_base" \
              -H "Authorization: Bearer $DENO_DEPLOY_TOKEN" \
              -H "Content-Type: application/json" \
              -d "{\"name\":\"$project\"}" || echo "000")
            if [ "$http_code" -ge 300 ] || [ "$http_code" -lt 200 ]; then
              echo "::error::Failed to create project $project (HTTP $http_code)"
              cat "$tmp_resp" || true
              exit 1
            fi
            echo "Created project $project"
          elif [ "$http_code" != "200" ]; then
            echo "::error::Failed to fetch project $project (HTTP $http_code)"
            cat "$tmp_resp" || true
            exit 1
          fi
          rm -f "$tmp_resp"

          if [ -n "$secrets_block" ]; then
            echo "::warning::project_secrets persistence via dash.deno.com API is no longer supported; forwarding these as runtime env for this deploy only."
            extra_runtime=""
            while IFS= read -r line; do
              line=$(echo "$line" | tr -d '\r' | xargs)
              [ -z "$line" ] && continue
              if ! printf '%s\n' "$line" | grep -q '='; then
                echo "::warning::project_secrets line missing '=': $line"
                continue
              fi
              secret_name=${line%%=*}
              env_key=${line#*=}
              if [ -z "$secret_name" ] || [ -z "$env_key" ]; then
                echo "::warning::project_secrets line invalid: $line"
                continue
              fi
              val="${!env_key:-}"
              if [ -z "$val" ]; then
                echo "::warning::Secret $secret_name skipped because env $env_key is empty"
                continue
              fi
              echo "::add-mask::$val"
              extra_runtime+=$'\n'"${secret_name}=${val}"
            done <<< "$secrets_block"

            if [ -n "$extra_runtime" ]; then
              combined="$(printf '%s\n' "$RUNTIME_ENV" "$extra_runtime" | tr -d '\r' | sed '/^$/d')"
              {
                echo "RUNTIME_ENV<<EOF"
                echo "$combined"
                echo "EOF"
              } >> "$GITHUB_ENV"
            fi
          fi

      - name: Deploy to Deno Deploy
        if: steps.preflight.outputs.deploy == 'yes'
        id: deploy
        run: |
          set -euo pipefail
          mode='${{ steps.target.outputs.mode }}'
          target='${{ steps.target.outputs.project }}'

          flags=(
            "--project=$target"
            "--entrypoint=$ENTRYPOINT"
            "--root=$ROOT_DIR"
            "--token=$DENO_DEPLOY_TOKEN"
          )

          if [ "$mode" = "production" ]; then
            flags+=("--prod")
          elif [ "$CREATE_PREVIEW" = "true" ]; then
            flags+=("--create")
          fi

          # Always include entrypoint and deno.json so deployctl finds the server.
          flags+=("--include=$ENTRYPOINT")
          if [ -f "deno.json" ]; then
            flags+=("--include=deno.json")
          fi

          while IFS= read -r inc; do
            inc=$(echo "$inc" | tr -d '\r' | xargs)
            [ -z "$inc" ] && continue
            flags+=("--include=$inc")
          done <<< "$INCLUDE"

          while IFS= read -r exc; do
            exc=$(echo "$exc" | tr -d '\r' | xargs)
            [ -z "$exc" ] && continue
            flags+=("--exclude=$exc")
          done <<< "$EXCLUDE"

          while IFS= read -r key; do
            key=$(echo "$key" | tr -d '\r' | xargs)
            [ -z "$key" ] && continue
            val="${!key:-}"
            if [ -n "$val" ]; then
              flags+=("--env-var=${key}=${val}")
            else
              echo "::warning::Requested env $key for deploy but it is empty"
            fi
          done <<< "$RUNTIME_ENV_KEYS"

          while IFS= read -r line; do
            line=$(echo "$line" | tr -d '\r')
            [ -z "$line" ] && continue
            if ! printf '%s\n' "$line" | grep -q '='; then
              echo "::warning::runtime_env line missing '=': $line"
              continue
            fi
            flags+=("--env-var=$line")
          done <<< "$RUNTIME_ENV"

          attempt=1
          poll_sleep=60
          start_time=$(date +%s)
          # Leave a small buffer so verify/summary steps can complete before hitting the 6h Actions limit.
          max_seconds=$(( 6 * 60 * 60 - 300 ))
            while true; do
              set +e
              output=$(deployctl deploy "${flags[@]}" 2>&1)
              status=$?
              set -e
              if [ $status -eq 0 ]; then
                echo "$output"
                deployment_url="$(printf '%s\n' "$output" | grep -oE "https://${target}-[A-Za-z0-9]+\\.deno\\.dev" | head -n 1 || true)"
                if [ -z "$deployment_url" ]; then
                  deployment_url="$(printf '%s\n' "$output" | grep -oE "https://${target}\\.deno\\.dev" | head -n 1 || true)"
                fi
                if [ -z "$deployment_url" ]; then
                  deployment_url="https://${target}.deno.dev"
                fi
                echo "deployment_url=$deployment_url" >> "$GITHUB_OUTPUT"
                break
              fi
            if echo "$output" | grep -q "Too many deployments created per hour"; then
              now=$(date +%s)
              elapsed=$(( now - start_time ))
              remaining=$(( max_seconds - elapsed ))
              if [ $remaining -le 0 ]; then
                echo "::error::Deno Deploy rate limit persisted for ~${elapsed}s; exhausted retry window (6h budget)"
                echo "$output"
                exit 1
              fi
              sleep_for=$poll_sleep
              if [ $sleep_for -gt $remaining ]; then
                sleep_for=$remaining
              fi
              echo "::warning::Deno Deploy rate limit (attempt ${attempt}); sleeping ${sleep_for}s (elapsed ${elapsed}s, remaining ${remaining}s)"
              sleep "$sleep_for"
              attempt=$(( attempt + 1 ))
              continue
            fi
            echo "$output"
            exit $status
          done

          echo "project=$target" >> "$GITHUB_OUTPUT"
          echo "mode=$mode" >> "$GITHUB_OUTPUT"

      - name: Compute deployed URLs
        if: steps.preflight.outputs.deploy == 'yes'
        id: deployed_url
        env:
          MODE: ${{ steps.deploy.outputs.mode }}
          TARGET_PROJECT: ${{ steps.deploy.outputs.project }}
          DEPLOYMENT_URL: ${{ steps.deploy.outputs.deployment_url || '' }}
        run: |
          set -euo pipefail
          mode="${MODE:-}"
          target_project="${TARGET_PROJECT:-}"
          prod_project="${PROJECT:-}"
          deployment_url="${DEPLOYMENT_URL:-}"

          project_url="https://${target_project}.deno.dev"
          router_url=""

          base=""
          if [[ "$prod_project" == *-ubq-fi ]]; then
            base="${prod_project%-ubq-fi}"
          fi

          if [ -n "$base" ]; then
            if [ "$mode" = "production" ]; then
              router_url="https://${base}.ubq.fi"
            else
              router_url="https://preview-${base}.ubq.fi"
            fi
          fi

          if [ -z "$deployment_url" ]; then
            deployment_url="$project_url"
          fi

          {
            echo "project_url=$project_url"
            echo "deployment_url=$deployment_url"
            echo "router_url=$router_url"
            echo "url=$deployment_url"
          } >> "$GITHUB_OUTPUT"

      - name: Comment deployment URL on PR
        if: steps.preflight.outputs.deploy == 'yes' && env.COMMENT_PR == 'true' && steps.deploy.outputs.mode == 'preview' && (github.event_name == 'pull_request' || github.event_name == 'push' || github.event_name == 'workflow_dispatch')
        continue-on-error: true
        env:
          GH_TOKEN: ${{ github.token }}
          EVENT_NAME: ${{ github.event_name }}
          PR_NUMBER: ${{ github.event.pull_request.number || '' }}
          REPO: ${{ github.repository }}
          SHA: ${{ github.event.pull_request.head.sha || github.sha }}
          TARGET_PROJECT: ${{ steps.deploy.outputs.project }}
          MODE: ${{ steps.deploy.outputs.mode }}
          DEPLOYMENT_URL: ${{ steps.deployed_url.outputs.deployment_url || format('https://{0}.deno.dev', steps.deploy.outputs.project) }}
          PROJECT_URL: ${{ steps.deployed_url.outputs.project_url || format('https://{0}.deno.dev', steps.deploy.outputs.project) }}
          ROUTER_URL: ${{ steps.deployed_url.outputs.router_url || '' }}
        run: |
          set -euo pipefail
          marker="<!-- deno-deploy-preview -->"
          project="${TARGET_PROJECT}"
          sha="${SHA}"
          deployment_url="${DEPLOYMENT_URL:-}"
          project_url="${PROJECT_URL:-}"
          router_url="${ROUTER_URL:-}"
          if [ -z "$deployment_url" ]; then
            deployment_url="$project_url"
          fi
          url_line="<${deployment_url}>"
          if [ -n "$router_url" ] && [ "$router_url" != "$deployment_url" ]; then
            url_line="<${deployment_url}> (router: <${router_url}>)"
          elif [ -n "$project_url" ] && [ "$project_url" != "$deployment_url" ]; then
            url_line="<${deployment_url}> (project: <${project_url}>)"
          fi
          timestamp="$(date -u +%Y-%m-%dT%H:%M:%SZ)"
          run_url="${GITHUB_SERVER_URL}/${REPO}/actions/runs/${GITHUB_RUN_ID}"

          pr_number="${PR_NUMBER:-}"
          if [ -z "$pr_number" ]; then
            pulls_url="https://api.github.com/repos/${REPO}/commits/${sha}/pulls"
            pulls_resp="$(mktemp)"
            pulls_code="$(curl -sS -o "$pulls_resp" -w "%{http_code}" -H "Authorization: Bearer $GH_TOKEN" -H "Accept: application/vnd.github+json" -H "X-GitHub-Api-Version: 2022-11-28" "$pulls_url" || echo "000")"
            pulls_json="$(cat "$pulls_resp" || true)"
            rm -f "$pulls_resp"
            if [ "$pulls_code" != "200" ]; then
              echo "::warning::Failed to resolve PR via $pulls_url (HTTP $pulls_code)"
            fi
            pr_number="$(
              PULLS_JSON="$pulls_json" python - <<'PY'
          import json, os

          raw = os.environ.get("PULLS_JSON", "") or "[]"
          num = ""
          try:
              data = json.loads(raw)
          except Exception:
              data = []

          if isinstance(data, list) and data:
              open_prs = [p for p in data if isinstance(p, dict) and p.get("state") == "open"]
              pr = open_prs[0] if open_prs else data[0]
              if isinstance(pr, dict):
                  num = str(pr.get("number") or "")

          print(num, end="")
          PY
            )"
          fi

          if [ -z "$pr_number" ]; then
            echo "No PR found for commit ${sha}; skipping comment."
            exit 0
          fi

          comments_url="https://api.github.com/repos/${REPO}/issues/${pr_number}/comments"
          comments_resp="$(mktemp)"
          comments_code="$(curl -sS -o "$comments_resp" -w "%{http_code}" -H "Authorization: Bearer $GH_TOKEN" -H "Accept: application/vnd.github+json" -H "X-GitHub-Api-Version: 2022-11-28" "$comments_url" || echo "000")"
          comments="$(cat "$comments_resp" || echo "[]")"
          rm -f "$comments_resp"
          if [ "$comments_code" -lt 200 ] || [ "$comments_code" -ge 300 ]; then
            echo "::warning::Failed to list PR comments (HTTP $comments_code) for $comments_url"
            comments="[]"
          fi

          existing_id="$(
            COMMENTS="$comments" MARKER="$marker" python - <<'PY'
          import json, os, sys

          raw = os.environ.get("COMMENTS", "") or "[]"
          marker = os.environ.get("MARKER", "")
          try:
              data = json.loads(raw)
          except Exception:
              data = []
          if not isinstance(data, list):
              data = []

          for c in data:
              body = (c or {}).get("body") or ""
              if marker and marker in body:
                  print((c or {}).get("id") or "", end="")
                  sys.exit(0)
          print("", end="")
          PY
          )"

          existing_body="$(
            COMMENTS="$comments" ID="$existing_id" python - <<'PY'
          import json, os

          raw = os.environ.get("COMMENTS", "") or "[]"
          cid = os.environ.get("ID", "")
          try:
              data = json.loads(raw)
          except Exception:
              data = []
          if not isinstance(data, list):
              data = []

          body = ""
          for c in data:
              if str((c or {}).get("id")) == str(cid):
                  body = (c or {}).get("body") or ""
                  break
          print(body, end="")
          PY
          )"

          new_body="$(
            EXISTING_BODY="$existing_body" MARKER="$marker" PROJECT="$project" URL_LINE="$url_line" SHA="$sha" MODE="$MODE" TIMESTAMP="$timestamp" RUN_URL="$run_url" python - <<'PY'
          import json, os, re
          
          marker = os.environ.get("MARKER", "<!-- deno-deploy-preview -->")
          project = os.environ.get("PROJECT", "")
          url_line = os.environ.get("URL_LINE", "")
          sha = os.environ.get("SHA", "")
          mode = os.environ.get("MODE", "preview")
          timestamp = os.environ.get("TIMESTAMP", "")
          run_url = os.environ.get("RUN_URL", "")

          body = os.environ.get("EXISTING_BODY", "") or ""
          if "\\n" in body and "\n" not in body:
              body = body.replace("\\n", "\n")
          
          data_match = re.search(r"<!--\\s*deno-deploy-preview:data\\s*(\\{.*?\\})\\s*-->", body, re.S)
          data = {}
          if data_match:
              try:
                  data = json.loads(data_match.group(1))
              except Exception:
                  data = {}
          if not isinstance(data, dict):
              data = {}

          projects = data.get("projects")
          if not isinstance(projects, dict):
              projects = {}

          if not data_match and marker in body:
              legacy_entries = {}
              for line in body.splitlines():
                  m = re.match(r"-\\s+`([^`]+)`:\\s*(.+)", line.strip())
                  if m:
                      legacy_entries[m.group(1)] = m.group(2).strip()

              legacy_sha = ""
              legacy_mode = ""
              note_match = re.search(r"_Updated from `([^`]+)` \\(([^)]+)\\)\\._", body)
              if note_match:
                  legacy_sha = note_match.group(1)
                  legacy_mode = note_match.group(2)

              for p, line in legacy_entries.items():
                  if not line:
                      continue
                  projects.setdefault(p, []).append(
                      {"ts": "", "sha": legacy_sha, "mode": legacy_mode, "url_line": line, "run_url": ""}
                  )

          if project and url_line:
              history = projects.setdefault(project, [])
              if not isinstance(history, list):
                  history = []
                  projects[project] = history
              if not history or history[-1].get("url_line") != url_line:
                  history.append(
                      {
                          "ts": timestamp,
                          "sha": sha,
                          "mode": mode,
                          "url_line": url_line,
                          "run_url": run_url,
                      }
                  )

          def render(pdata: dict, truncated: bool) -> str:
              payload = {"version": 1, "projects": pdata}
              data_line = "<!-- deno-deploy-preview:data " + json.dumps(
                  payload, separators=(",", ":"), sort_keys=True
              ) + " -->"

              lines = [marker, data_line, "### Deno Deploy Previews", ""]
              for p in sorted(pdata.keys()):
                  lines.append(f"- `{p}`")
                  history = pdata.get(p) or []
                  if isinstance(history, list):
                      for entry in reversed(history):
                          entry = entry or {}
                          ts = entry.get("ts") or ""
                          sha_val = entry.get("sha") or ""
                          sha_short = sha_val[:7] if sha_val else ""
                          mode_val = entry.get("mode") or ""
                          url_val = entry.get("url_line") or ""
                          run_val = entry.get("run_url") or ""

                          prefix_bits = []
                          if ts:
                              prefix_bits.append(ts)
                          if sha_short:
                              prefix_bits.append(f"`{sha_short}`")
                          if mode_val:
                              prefix_bits.append(f"({mode_val})")
                          prefix = " ".join(prefix_bits).strip()

                          line = f"  - {prefix}: {url_val}" if prefix else f"  - {url_val}"
                          if run_val:
                              if not (run_val.startswith("<") and run_val.endswith(">")):
                                  run_val = f"<{run_val}>"
                              line += f" (run: {run_val})"
                          lines.append(line)
                  lines.append("")

              while lines and lines[-1] == "":
                  lines.pop()
              if truncated:
                  lines.append("")
                  lines.append("_History truncated to fit GitHub comment size limits._")
              return "\n".join(lines)

          MAX_BODY_CHARS = 60000
          truncated = False
          rendered = render(projects, truncated=False)
          while len(rendered) > MAX_BODY_CHARS:
              longest = None
              for p, history in projects.items():
                  if not isinstance(history, list) or len(history) <= 1:
                      continue
                  if longest is None or len(history) > len(projects[longest]):
                      longest = p
              if longest is None:
                  break
              projects[longest].pop(0)
              truncated = True
              rendered = render(projects, truncated=False)

          print(render(projects, truncated=truncated), end="")
          PY
          )"

          payload="$(
            BODY="$new_body" python - <<'PY'
          import json, os
          print(json.dumps({"body": os.environ.get("BODY", "")}))
          PY
          )"

          tmp_resp="$(mktemp)"
          http_code="000"
          if [ -n "$existing_id" ]; then
            http_code="$(curl -sS -o "$tmp_resp" -w "%{http_code}" -X PATCH \
              -H "Authorization: Bearer $GH_TOKEN" \
              -H "Accept: application/vnd.github+json" \
              -H "X-GitHub-Api-Version: 2022-11-28" \
              "https://api.github.com/repos/${REPO}/issues/comments/${existing_id}" \
              -d "$payload" || echo "000")"
            if [ "$http_code" != "200" ]; then
              echo "::error::Failed to update PR comment ${existing_id} (HTTP $http_code)"
              cat "$tmp_resp" || true
              rm -f "$tmp_resp"
              exit 1
            fi
            echo "Updated PR comment ${existing_id} with ${project} -> ${url_line} (HTTP $http_code)"
          else
            http_code="$(curl -sS -o "$tmp_resp" -w "%{http_code}" -X POST \
              -H "Authorization: Bearer $GH_TOKEN" \
              -H "Accept: application/vnd.github+json" \
              -H "X-GitHub-Api-Version: 2022-11-28" \
              "$comments_url" \
              -d "$payload" || echo "000")"
            if [ "$http_code" != "201" ]; then
              echo "::error::Failed to create PR comment (HTTP $http_code)"
              cat "$tmp_resp" || true
              rm -f "$tmp_resp"
              exit 1
            fi
            new_id="$(
              RESP_FILE="$tmp_resp" python - <<'PY'
          import json, os

          path = os.environ.get("RESP_FILE", "")
          try:
              with open(path, "r", encoding="utf-8") as f:
                  data = json.load(f)
          except Exception:
              data = {}

          print(str((data or {}).get("id") or ""), end="")
          PY
            )"
            echo "Created PR comment ${new_id:-<unknown>} for ${project} -> ${url_line} (HTTP $http_code)"
          fi
          rm -f "$tmp_resp"

      - name: Verify deployment
        if: steps.preflight.outputs.deploy == 'yes' && env.VERIFY_URL == 'true'
        id: verify
        continue-on-error: true
        run: |
          set -euo pipefail
          url='${{ steps.deployed_url.outputs.deployment_url }}'
          if [ -z "$url" ]; then url="https://${{ steps.deploy.outputs.project }}.deno.dev"; fi
          codes_ok="200"
          status="fail"
          http_code="000"
          for _ in 1 2 3; do
            http_code=$(curl -sS -L -o /dev/null -w "%{http_code}" "$url" || echo "000")
            if echo "$codes_ok" | grep -q "\b$http_code\b"; then
              status="ok"
              break
            fi
            sleep 5
          done
          echo "http_code=$http_code" >> "$GITHUB_OUTPUT"
          echo "status=$status" >> "$GITHUB_OUTPUT"
          if [ "$status" != "ok" ]; then
            echo "::error::Deployment probe returned HTTP $http_code at $url"
          fi

      - name: Debug fetch paths (optional)
        if: steps.preflight.outputs.deploy == 'yes' && env.DEBUG_FETCH_PATHS != ''
        run: |
          set -euo pipefail
          base='${{ steps.deployed_url.outputs.deployment_url }}'
          if [ -z "$base" ]; then base="https://${{ steps.deploy.outputs.project }}.deno.dev"; fi
          ok_codes="200 301 302 304 308"
          # Retry a few times for transient deployctl/edge blips (occasionally returns 5xx/000 right after deploy).
          retryable_codes="000 404 429 500 502 503 504 599"
          max_attempts=6
          misses=()
          summary=""

          # Give the edge a moment to pick up the new deployment before probing assets.
          sleep 10

          while IFS= read -r raw; do
            raw=$(echo "$raw" | tr -d '\r' | xargs)
            [ -z "$raw" ] && continue
            case "$raw" in
              http://*|https://*) url="$raw" ;;
              /*) url="${base%/}$raw" ;;
              *) url="${base%/}/$raw" ;;
            esac
            attempt=1
            http_code="000"
            while true; do
              http_code=$(curl -sS -o /dev/null -w "%{http_code}" "$url" || echo "000")
              if echo "$ok_codes" | grep -q "\b$http_code\b"; then
                break
              fi
              if echo "$retryable_codes" | grep -q "\b$http_code\b" && [ $attempt -lt $max_attempts ]; then
                sleep $(( attempt * 2 ))
                attempt=$(( attempt + 1 ))
                continue
              fi
              break
            done

            if echo "$ok_codes" | grep -q "\b$http_code\b"; then
              note=""
              if [ $attempt -gt 1 ]; then
                note=" after ${attempt} attempts"
              fi
              summary+="- [ok] $url (HTTP $http_code${note})\n"
            else
              summary+="- [miss] $url (HTTP $http_code after ${attempt} attempts)\n"
              misses+=("$url")
            fi
          done <<< "$DEBUG_FETCH_PATHS"

          {
            echo "### Debug fetch"
            echo ""
            printf "%b" "$summary"
          } >> "$GITHUB_STEP_SUMMARY"

          if [ ${#misses[@]} -gt 0 ] && [ "${DEBUG_FETCH_FAIL:-false}" = "true" ]; then
            echo "::error::Debug fetch failures: ${misses[*]}"
            exit 1
          fi

      - name: Summary
        if: steps.preflight.outputs.deploy == 'yes'
        run: |
          mode='${{ steps.deploy.outputs.mode }}'
          project='${{ steps.deploy.outputs.project }}'
          deployment_url="${{ steps.deployed_url.outputs.deployment_url || '' }}"
          project_url="${{ steps.deployed_url.outputs.project_url || '' }}"
          router_url="${{ steps.deployed_url.outputs.router_url || '' }}"
          http="${{ steps.verify.outputs.http_code || '' }}"
          status="${{ steps.verify.outputs.status || '' }}"
          {
            echo "### Deno Deploy"
            echo ""
            echo "- Mode: ${mode:-unknown}"
            echo "- Project: ${project}"
            if [ -n "$router_url" ]; then echo "- Router URL: ${router_url}"; fi
            if [ -n "$deployment_url" ]; then echo "- Deployment URL: ${deployment_url}"; fi
            if [ -n "$project_url" ]; then echo "- Project URL: ${project_url}"; fi
            if [ -n "$http" ]; then
              echo "- HTTP: ${http} (${status})"
            fi
            echo "- Ref: ${GITHUB_REF##*/}"
          } >> "$GITHUB_STEP_SUMMARY"

      - name: Fail on probe failure
        if: steps.preflight.outputs.deploy == 'yes' && env.VERIFY_URL == 'true'
        run: |
          status='${{ steps.verify.outputs.status || '' }}'
          http='${{ steps.verify.outputs.http_code || '' }}'
          url='${{ steps.deployed_url.outputs.deployment_url || '' }}'
          if [ "$status" != "ok" ]; then
            echo "::error::Deployment probe failed with HTTP ${http:-unknown} at ${url:-<missing url>}"
            exit 1
          fi
