name: Reusable - Deno Deploy

on:
  workflow_call:
    inputs:
      project:
        description: Optional Deno Deploy project name for production (defaults to derived from repository name)
        required: false
        type: string
        default: ""
      preview_project:
        description: Optional preview project name (defaults to "preview-<project>")
        required: false
        type: string
        default: ""
      entrypoint:
        description: Entrypoint file passed to deployctl (relative to root)
        required: true
        type: string
      root:
        description: Directory to deploy from
        required: false
        type: string
        default: "."
      deno_version:
        description: Deno version range
        required: false
        type: string
        default: v2.x
      deployctl_version:
        description: deployctl version to install
        required: false
        type: string
        default: "1.12.0"
      install_command:
        description: Optional install command (multi-line allowed)
        required: false
        type: string
        default: ""
      build_command:
        description: Optional build command (multi-line allowed)
        required: false
        type: string
        default: ""
      node_version:
        description: Set to install Node.js (empty to skip)
        required: false
        type: string
        default: ""
      bun_version:
        description: Set to install Bun (empty to skip)
        required: false
        type: string
        default: ""
      include:
        description: Newline-separated include globs for deployctl
        required: false
        type: string
        default: ""
      exclude:
        description: Newline-separated exclude globs for deployctl
        required: false
        type: string
        default: |
          .git
          .github
          node_modules
          dist
          build
          coverage
          .turbo
          .next
          .vercel
      env_var_keys:
        description: Newline-separated env var names to forward as --env-var
        required: false
        type: string
        default: ""
      runtime_env:
        description: Newline-separated KEY=VALUE lines to forward as --env-var (preferred)
        required: false
        type: string
        default: ""
      build_env:
        description: Newline-separated KEY=VALUE lines to export before install/build
        required: false
        type: string
        default: ""
      ensure_project:
        description: Ensure the target project exists via Deno Deploy API before deploying
        required: false
        type: boolean
        default: true
      project_secrets:
        description: Newline-separated SECRET_NAME=ENV_VAR mappings to persist as Deno Deploy secrets (production and fallback)
        required: false
        type: string
        default: ""
      preview_project_secrets:
        description: Optional SECRET_NAME=ENV_VAR mappings for preview deployments (overrides project_secrets)
        required: false
        type: string
        default: ""
      required_env:
        description: Newline-separated env vars that must be present to deploy
        required: false
        type: string
        default: |
          DENO_DEPLOY_TOKEN
      submodules:
        description: Submodules checkout mode (empty to skip, 'recursive' for recursive)
        required: false
        type: string
        default: ""
      verify_url:
        description: Probe the deployed URL after deploy
        required: false
        type: boolean
        default: true
      debug_fetch_paths:
        description: Optional newline-separated URLs or paths (relative to deployed base URL) to GET after deploy for debugging
        required: false
        type: string
        default: ""
      debug_fetch_fail:
        description: Fail the workflow if any debug fetch returns a non-2xx/3xx status
        required: false
        type: boolean
        default: false
      create_preview:
        description: Create preview project when missing
        required: false
        type: boolean
        default: true
      prod_branch:
        description: Branch name for production deployments
        required: false
        type: string
        default: ""
    secrets:
      DENO_DEPLOY_TOKEN:
        required: true
      SUPABASE_URL:
        required: false
      SUPABASE_ANON_KEY:
        required: false
      DENO_PROJECT_SECRETS:
        required: false
      DENO_PREVIEW_PROJECT_SECRETS:
        required: false
      CLOUDFLARE_ACCOUNT_ID:
        required: false
      CLOUDFLARE_ZONE_ID:
        required: false
      CLOUDFLARE_API_TOKEN:
        required: false

permissions:
  contents: read
  id-token: write

jobs:
  deploy:
    name: Deno Deploy
    runs-on: ubuntu-22.04
    concurrency:
      group: deno-deploy-${{ inputs.project }}-${{ github.ref }}
      cancel-in-progress: true
    env:
      PROD_BRANCH: ${{ inputs.prod_branch != '' && inputs.prod_branch || github.event.repository.default_branch }}
      PROJECT: ${{ inputs.project }}
      PREVIEW_PROJECT: ${{ inputs.preview_project }}
      ENTRYPOINT: ${{ inputs.entrypoint }}
      ROOT_DIR: ${{ inputs.root }}
      INCLUDE: ${{ inputs.include }}
      EXCLUDE: ${{ inputs.exclude }}
      RUNTIME_ENV_KEYS: ${{ inputs.env_var_keys }}
      RUNTIME_ENV: ${{ inputs.runtime_env }}
      BUILD_ENV: ${{ inputs.build_env }}
      ENSURE_PROJECT: ${{ inputs.ensure_project }}
      PROJECT_SECRETS: ${{ inputs.project_secrets != '' && inputs.project_secrets || secrets.DENO_PROJECT_SECRETS || '' }}
      PREVIEW_PROJECT_SECRETS: ${{ inputs.preview_project_secrets != '' && inputs.preview_project_secrets || secrets.DENO_PREVIEW_PROJECT_SECRETS || '' }}
      REQUIRED_ENV: ${{ inputs.required_env }}
      BUILD_COMMAND: ${{ inputs.build_command }}
      INSTALL_COMMAND: ${{ inputs.install_command }}
      CREATE_PREVIEW: ${{ inputs.create_preview }}
      VERIFY_URL: ${{ inputs.verify_url }}
      DEBUG_FETCH_PATHS: ${{ inputs.debug_fetch_paths }}
      DEBUG_FETCH_FAIL: ${{ inputs.debug_fetch_fail }}
      DENO_VERSION: ${{ inputs.deno_version }}
      DEPLOYCTL_VERSION: ${{ inputs.deployctl_version }}
      NODE_VERSION: ${{ inputs.node_version }}
      BUN_VERSION: ${{ inputs.bun_version }}
      DENO_DEPLOY_TOKEN: ${{ secrets.DENO_DEPLOY_TOKEN }}
      SUPABASE_URL: ${{ secrets.SUPABASE_URL || '' }}
      SUPABASE_ANON_KEY: ${{ secrets.SUPABASE_ANON_KEY || '' }}
      CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID || '' }}
      CLOUDFLARE_ZONE_ID: ${{ secrets.CLOUDFLARE_ZONE_ID || '' }}
      CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN || '' }}
      NPM_CONFIG_REGISTRY: https://registry.npmjs.org

    steps:
      - name: Check out repository
        uses: actions/checkout@v4
        with:
          submodules: ${{ inputs.submodules }}

      - name: Set up Deno
        uses: denoland/setup-deno@v2
        with:
          deno-version: ${{ env.DENO_VERSION }}

      - name: Set up Node.js (optional)
        if: env.NODE_VERSION != ''
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: npm

      - name: Install Bun (optional)
        if: env.BUN_VERSION != ''
        run: |
          set -euo pipefail
          # Use the official install script to avoid setup-bun cache/download flakes.
          BUN_VERSION="${BUN_VERSION}" curl -fsSL https://bun.sh/install | bash
          echo "${HOME}/.bun/bin" >> "$GITHUB_PATH"

      - name: Install deployctl
        run: |
          set -euo pipefail
          deno install -gArf jsr:@deno/deployctl@${{ env.DEPLOYCTL_VERSION }}
          echo "${HOME}/.deno/bin" >> "$GITHUB_PATH"

      - name: Preflight (token and required env)
        id: preflight
        run: |
          set -euo pipefail
          missing=()
          while IFS= read -r key; do
            key=$(echo "$key" | tr -d '\r' | xargs)
            [ -z "$key" ] && continue
            if [ -z "${!key:-}" ]; then
              missing+=("$key")
            fi
          done <<< "$REQUIRED_ENV"

          if [ ${#missing[@]} -gt 0 ]; then
            echo "deploy=no" >> "$GITHUB_OUTPUT"
            {
              echo "### Deno Deploy"
              echo ""
              echo "- Skipped: missing env vars -> ${missing[*]}"
            } >> "$GITHUB_STEP_SUMMARY"
          else
            echo "deploy=yes" >> "$GITHUB_OUTPUT"
          fi

      - name: Determine target project
        if: steps.preflight.outputs.deploy == 'yes'
        id: target
        env:
          REF_NAME: ${{ github.ref_name }}
        run: |
          set -euo pipefail
          project="${PROJECT:-}"
          if [[ "$project" != *-ubq-fi ]]; then
            echo "::error::Project name must end with '-ubq-fi' to match router mapping. Got: $project"
            exit 1
          fi
          if [ ${#project} -gt 26 ]; then
            echo "::error::Base project name '${project}' exceeds 26 characters (Deno Deploy's max project name character limit)"
            exit 1
          fi

          preview="${PREVIEW_PROJECT:-}"
          if [ -z "$preview" ]; then
            base="${project%-ubq-fi}"
            # Clamp base to keep preview <=26 with prefix/suffix: p- + base + -ubq-fi
            if [ ${#base} -gt 17 ]; then
              # 12 chars + dash + 4-char hash = 17
              hash=$(printf '%s' "$base" | sha1sum | cut -c1-4)
              base="${base:0:12}-${hash}"
            fi
            preview="p-${base}-ubq-fi"
          fi

          if [ ${#preview} -gt 26 ]; then
            echo "::error::Preview project name '${preview}' exceeds 26 characters (Deno Deploy's max project name character limit)"
            exit 1
          fi

          mode="preview"
          target="$preview"
          if [ "$REF_NAME" = "$PROD_BRANCH" ]; then
            mode="production"
            target="$project"
          fi

          echo "mode=$mode" >> "$GITHUB_OUTPUT"
          echo "project=$target" >> "$GITHUB_OUTPUT"

      - name: Export build env
        if: steps.preflight.outputs.deploy == 'yes' && env.BUILD_ENV != ''
        run: |
          set -euo pipefail
          echo "$BUILD_ENV" >> "$GITHUB_ENV"

      - name: Install dependencies
        if: steps.preflight.outputs.deploy == 'yes' && env.INSTALL_COMMAND != ''
        run: |
          set -euo pipefail
          printf '%s\n' "$INSTALL_COMMAND" | bash

      - name: Build
        if: steps.preflight.outputs.deploy == 'yes' && env.BUILD_COMMAND != ''
        run: |
          set -euo pipefail
          printf '%s\n' "$BUILD_COMMAND" | bash

      - name: Ensure project exists and sync secrets
        if: steps.preflight.outputs.deploy == 'yes'
        env:
          MODE: ${{ steps.target.outputs.mode }}
          TARGET_PROJECT: ${{ steps.target.outputs.project }}
        run: |
          set -euo pipefail
          project="${TARGET_PROJECT:-}"
          mode="${MODE:-}"
          if [ -z "$project" ]; then
            echo "::error::Target project was not resolved"
            exit 1
          fi

          secrets_block="$PROJECT_SECRETS"
          if [ "$mode" = "preview" ] && [ -n "$PREVIEW_PROJECT_SECRETS" ]; then
            secrets_block="$PREVIEW_PROJECT_SECRETS"
          fi

          if [ "$ENSURE_PROJECT" != "true" ] && [ -z "$secrets_block" ]; then
            echo "Skipping project ensure/secret sync (disabled and no secrets provided)"
            exit 0
          fi

          api_base="https://dash.deno.com/api/projects"
          tmp_resp="$(mktemp)"
          http_code=$(curl -sS -o "$tmp_resp" -w "%{http_code}" \
            -H "Authorization: Bearer $DENO_DEPLOY_TOKEN" \
            "$api_base/$project" || echo "000")

          if [ "$http_code" = "404" ]; then
            if [ "$ENSURE_PROJECT" != "true" ]; then
              echo "::error::Project $project not found and ensure_project is false"
              cat "$tmp_resp" || true
              exit 1
            fi
            http_code=$(curl -sS -o "$tmp_resp" -w "%{http_code}" \
              -X POST "$api_base" \
              -H "Authorization: Bearer $DENO_DEPLOY_TOKEN" \
              -H "Content-Type: application/json" \
              -d "{\"name\":\"$project\"}" || echo "000")
            if [ "$http_code" -ge 300 ] || [ "$http_code" -lt 200 ]; then
              echo "::error::Failed to create project $project (HTTP $http_code)"
              cat "$tmp_resp" || true
              exit 1
            fi
            echo "Created project $project"
          elif [ "$http_code" != "200" ]; then
            echo "::error::Failed to fetch project $project (HTTP $http_code)"
            cat "$tmp_resp" || true
            exit 1
          fi
          rm -f "$tmp_resp"

          if [ -n "$secrets_block" ]; then
            while IFS= read -r line; do
              line=$(echo "$line" | tr -d '\r' | xargs)
              [ -z "$line" ] && continue
              if ! printf '%s\n' "$line" | grep -q '='; then
                echo "::warning::project_secrets line missing '=': $line"
                continue
              fi
              secret_name=${line%%=*}
              env_key=${line#*=}
              if [ -z "$secret_name" ] || [ -z "$env_key" ]; then
                echo "::warning::project_secrets line invalid: $line"
                continue
              fi
              val="${!env_key:-}"
              if [ -z "$val" ]; then
                echo "::warning::Secret $secret_name skipped because env $env_key is empty"
                continue
              fi
              echo "::add-mask::$val"
              tmp_secret="$(mktemp)"
              code=$(curl -sS -o "$tmp_secret" -w "%{http_code}" \
                -X POST "$api_base/$project/secrets" \
                -H "Authorization: Bearer $DENO_DEPLOY_TOKEN" \
                -H "Content-Type: application/json" \
                -d "{\"name\":\"$secret_name\",\"value\":\"$val\"}" || echo "000")
              if [ "$code" != "200" ]; then
                echo "::error::Failed to set secret $secret_name (HTTP $code)"
                cat "$tmp_secret" || true
                rm -f "$tmp_secret"
                exit 1
              fi
              rm -f "$tmp_secret"
            done <<< "$secrets_block"
          fi

      - name: Deploy to Deno Deploy
        if: steps.preflight.outputs.deploy == 'yes'
        id: deploy
        run: |
          set -euo pipefail
          mode='${{ steps.target.outputs.mode }}'
          target='${{ steps.target.outputs.project }}'

          flags=(
            "--project=$target"
            "--entrypoint=$ENTRYPOINT"
            "--root=$ROOT_DIR"
            "--token=$DENO_DEPLOY_TOKEN"
          )

          if [ "$mode" = "production" ]; then
            flags+=("--prod")
          elif [ "$CREATE_PREVIEW" = "true" ]; then
            flags+=("--create")
          fi

          # Always include entrypoint and deno.json so deployctl finds the server.
          flags+=("--include=$ENTRYPOINT")
          if [ -f "deno.json" ]; then
            flags+=("--include=deno.json")
          fi

          while IFS= read -r inc; do
            inc=$(echo "$inc" | tr -d '\r' | xargs)
            [ -z "$inc" ] && continue
            flags+=("--include=$inc")
          done <<< "$INCLUDE"

          while IFS= read -r exc; do
            exc=$(echo "$exc" | tr -d '\r' | xargs)
            [ -z "$exc" ] && continue
            flags+=("--exclude=$exc")
          done <<< "$EXCLUDE"

          while IFS= read -r key; do
            key=$(echo "$key" | tr -d '\r' | xargs)
            [ -z "$key" ] && continue
            val="${!key:-}"
            if [ -n "$val" ]; then
              flags+=("--env-var=${key}=${val}")
            else
              echo "::warning::Requested env $key for deploy but it is empty"
            fi
          done <<< "$RUNTIME_ENV_KEYS"

          while IFS= read -r line; do
            line=$(echo "$line" | tr -d '\r')
            [ -z "$line" ] && continue
            if ! printf '%s\n' "$line" | grep -q '='; then
              echo "::warning::runtime_env line missing '=': $line"
              continue
            fi
            flags+=("--env-var=$line")
          done <<< "$RUNTIME_ENV"

          attempt=1
          max_attempts=6
          while true; do
            set +e
            output=$(deployctl deploy "${flags[@]}" 2>&1)
            status=$?
            set -e
            if [ $status -eq 0 ]; then
              echo "$output"
              break
            fi
            if echo "$output" | grep -q "Too many deployments created per hour"; then
              if [ $attempt -ge $max_attempts ]; then
                echo "::error::Deno Deploy rate limit hit after ${attempt} attempts"
                echo "$output"
                exit 1
              fi
              echo "::warning::Deno Deploy rate limit (attempt ${attempt}/${max_attempts}); retrying shortly"
              sleep 5
              attempt=$(( attempt + 1 ))
              continue
            fi
            echo "$output"
            exit $status
          done

          echo "project=$target" >> "$GITHUB_OUTPUT"
          echo "mode=$mode" >> "$GITHUB_OUTPUT"

      - name: Determine deployed URL
        if: steps.preflight.outputs.deploy == 'yes' && env.VERIFY_URL == 'true'
        id: deployed_url
        run: |
          set -euo pipefail
          project="${{ steps.deploy.outputs.project }}"
          fallback="https://${project}.deno.dev"
          resp=$(curl -sS -H "Authorization: Bearer $DENO_DEPLOY_TOKEN" "https://dash.deno.com/api/projects/${project}" || true)
          URL=$(PROJECT="$project" FALLBACK="$fallback" RESP="$resp" cat <<'PY' | sed 's/^  //' | python -
            import json, os, sys

            resp = os.environ.get("RESP", "")
            fallback = os.environ.get("FALLBACK", "")
            url = fallback
            try:
                data = json.loads(resp or "{}")
                domains = data.get("domains") or []
                if isinstance(domains, list) and domains:
                    dom = domains[0]
                    if isinstance(dom, dict):
                        dom = dom.get("domain") or dom.get("name") or ""
                    if dom:
                        url = f"https://{dom}"
            except Exception as exc:  # noqa: BLE001
                sys.stderr.write(f"Warning: failed to parse project domains: {exc}\n")
            print(url, end="")
          PY
          )
          if [ -z "$URL" ]; then
            URL="$fallback"
          fi
          echo "url=$URL" >> "$GITHUB_OUTPUT"

      - name: Log Cloudflare secrets presence
        if: steps.preflight.outputs.deploy == 'yes' && env.VERIFY_URL == 'true'
        run: |
          set -euo pipefail
          acct="missing"
          zone="missing"
          token="missing"
          [ -n "${CLOUDFLARE_ACCOUNT_ID:-}" ] && acct="present"
          [ -n "${CLOUDFLARE_ZONE_ID:-}" ] && zone="present"
          [ -n "${CLOUDFLARE_API_TOKEN:-}" ] && token="present"
          echo "Cloudflare secrets - account_id: $acct, zone_id: $zone, api_token: $token"

      - name: Debug Cloudflare Lists API
        if: steps.preflight.outputs.deploy == 'yes' && env.VERIFY_URL == 'true' && env.CLOUDFLARE_ACCOUNT_ID != '' && env.CLOUDFLARE_ZONE_ID != '' && env.CLOUDFLARE_API_TOKEN != ''
        run: |
          set -euo pipefail
          response=$(curl --request GET \
            --url "https://api.cloudflare.com/client/v4/accounts/$CLOUDFLARE_ACCOUNT_ID/rules/lists" \
            --header 'Content-Type: application/json' \
            --header "Authorization: Bearer $CLOUDFLARE_API_TOKEN")
          echo "Lists API response: $response"

      - name: Bypass Cloudflare for GitHub Actions (optional)
        if: steps.preflight.outputs.deploy == 'yes' && env.VERIFY_URL == 'true' && env.CLOUDFLARE_ACCOUNT_ID != '' && env.CLOUDFLARE_ZONE_ID != '' && env.CLOUDFLARE_API_TOKEN != ''
        uses: xiaotianxt/bypass-cloudflare-for-github-action@v2.0.1
        with:
          cf_account_id: ${{ env.CLOUDFLARE_ACCOUNT_ID }}
          cf_zone_id: ${{ env.CLOUDFLARE_ZONE_ID }}
          cf_api_token: ${{ env.CLOUDFLARE_API_TOKEN }}

      - name: Collect probe URLs
        if: steps.preflight.outputs.deploy == 'yes' && env.VERIFY_URL == 'true'
        id: probe_urls
        env:
          DEPLOYED_URL: ${{ steps.deployed_url.outputs.url }}
          TARGET_PROJECT: ${{ steps.deploy.outputs.project }}
        run: |
          set -euo pipefail
          primary="${DEPLOYED_URL:-}"
          project="${TARGET_PROJECT:-}"
          if [ -z "$project" ]; then
            echo "::error::Target project missing; cannot build probe URLs"
            exit 1
          fi

          deno="https://${project}.deno.dev"
          router=""

          if [[ "$project" =~ ^p-(.+)-ubq-fi$ ]]; then
            base="${BASH_REMATCH[1]}"
            router="https://preview-${base}.ubq.fi"
          elif [[ "$project" =~ ^(.+)-ubq-fi$ ]]; then
            base="${BASH_REMATCH[1]}"
            router="https://${base}.ubq.fi"
          fi

          urls=()
          add_url() {
            local u="$1"
            [ -z "$u" ] && return
            for existing in "${urls[@]:-}"; do
              if [ "$existing" = "$u" ]; then
                return
              fi
            done
            urls+=("$u")
          }

          add_url "$primary"
          add_url "$deno"
          add_url "$router"

          {
            echo "deno_base=$deno"
            echo "router_base=$router"
            echo "urls<<EOF"
            printf '%s\n' "${urls[@]}"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"

      - name: Verify deployment
        if: steps.preflight.outputs.deploy == 'yes' && env.VERIFY_URL == 'true'
        id: verify
        continue-on-error: true
        env:
          PROBE_URLS: ${{ steps.probe_urls.outputs.urls }}
        run: |
          set -euo pipefail
          probes="${PROBE_URLS:-}"
          if [ -z "$probes" ]; then
            echo "status=fail" >> "$GITHUB_OUTPUT"
            echo "::error::No probe URLs collected for verification"
            exit 0
          fi

          codes_ok="200 301 302 304 308"
          summary=""
          failures=()
          status="ok"

          while IFS= read -r raw; do
            url=$(echo "$raw" | tr -d '\r' | xargs)
            [ -z "$url" ] && continue
            http_code="000"
            for _ in 1 2 3; do
              http_code=$(curl -sS -L -o /dev/null -w "%{http_code}" "$url" || echo "000")
              if echo "$codes_ok" | grep -q "\b$http_code\b"; then
                break
              fi
              sleep 3
            done

            if echo "$codes_ok" | grep -q "\b$http_code\b"; then
              summary+="- [ok] $url (HTTP $http_code)\n"
            else
              summary+="- [miss] $url (HTTP $http_code)\n"
              failures+=("$url (HTTP $http_code)")
              status="fail"
            fi
          done <<< "$probes"

          if [ -z "$summary" ]; then
            status="fail"
            msg="No probe URLs were processed"
            failures+=("$msg")
            summary+="- [miss] $msg\n"
          fi

          {
            echo "### HTTP probe"
            echo ""
            printf "%b" "$summary"
          } >> "$GITHUB_STEP_SUMMARY"

          echo "status=$status" >> "$GITHUB_OUTPUT"
          if [ ${#failures[@]} -gt 0 ]; then
            {
              echo "failures<<EOF"
              printf '%s\n' "${failures[@]}"
              echo "EOF"
            } >> "$GITHUB_OUTPUT"
          fi

      - name: Debug fetch paths and assets
        if: steps.preflight.outputs.deploy == 'yes' && env.VERIFY_URL == 'true'
        env:
          DENO_BASE: ${{ steps.probe_urls.outputs.deno_base }}
          ROUTER_BASE: ${{ steps.probe_urls.outputs.router_base }}
        run: |
          set -euo pipefail
          deno_base="${DENO_BASE:-}"
          router_base="${ROUTER_BASE:-}"
          bases=()
          [ -n "$deno_base" ] && bases+=("$deno_base")
          [ -n "$router_base" ] && bases+=("$router_base")

          ok_codes="200 301 302 304 308"
          summary=""
          seen_urls=()
          misses=()
          record_seen() {
            local url="$1"
            for seen in "${seen_urls[@]:-}"; do
              if [ "$seen" = "$url" ]; then
                return
              fi
            done
            seen_urls+=("$url")
          }

          asset_paths=()

          for base in "${bases[@]}"; do
            [ -z "$base" ] && continue
            root="${base%/}/"
            tmp_html="$(mktemp)"
            http_code=$(curl -sS -L -w "%{http_code}" -o "$tmp_html" "$root" || echo "000")
            record_seen "$root"
            if echo "$ok_codes" | grep -q "\b$http_code\b"; then
              summary+="- [ok] $root (HTTP $http_code)\n"
              found_paths=()
              mapfile -t found_paths < <(HTML_FILE="$tmp_html" BASE="$root" python - <<'PY'
          import os
          import sys
          from pathlib import Path
          from html.parser import HTMLParser
          from urllib.parse import urljoin, urlparse

          base = os.environ.get("BASE", "")
          html_path = os.environ.get("HTML_FILE", "")
          html = Path(html_path).read_text() if html_path else sys.stdin.read()
          base_host = urlparse(base).netloc
          paths = set()

          class Extract(HTMLParser):
              def handle_starttag(self, tag, attrs):
                  for name, value in attrs:
                      if name not in ("src", "href"):
                          continue
                      if not value or value.startswith(("data:", "mailto:", "tel:", "#", "javascript:")):
                          continue
                      abs_url = urljoin(base, value)
                      parsed = urlparse(abs_url)
                      if parsed.scheme not in ("http", "https"):
                          continue
                      if parsed.netloc and parsed.netloc != base_host:
                          continue
                      path = parsed.path or "/"
                      if parsed.query:
                          path = f"{path}?{parsed.query}"
                      paths.add(path)

          Extract().feed(html)
          for path in sorted(paths):
              print(path)
          PY
              )
              if [ ${#found_paths[@]} -gt 0 ]; then
                asset_paths+=("${found_paths[@]}")
              fi
            else
              summary+="- [miss] $root (HTTP $http_code)\n"
              misses+=("$root")
            fi
            rm -f "$tmp_html"
          done

          if [ ${#asset_paths[@]} -gt 0 ]; then
            mapfile -t asset_paths < <(printf "%s\n" "${asset_paths[@]}" | awk 'NF && !seen[$0]++')
          fi

          debug_paths=()
          while IFS= read -r raw; do
            raw=$(echo "$raw" | tr -d '\r' | xargs)
            [ -z "$raw" ] && continue
            debug_paths+=("$raw")
          done <<< "$DEBUG_FETCH_PATHS"

          fetch_paths=("${asset_paths[@]}")
          fetch_paths+=("${debug_paths[@]}")
          if [ ${#fetch_paths[@]} -gt 0 ]; then
            mapfile -t fetch_paths < <(printf "%s\n" "${fetch_paths[@]}" | awk 'NF && !seen[$0]++')
          fi

          for path in "${fetch_paths[@]:-}"; do
            for base in "${bases[@]}"; do
              [ -z "$base" ] && continue
              case "$path" in
                http://*|https://*) url="$path" ;;
                /*) url="${base%/}$path" ;;
                *) url="${base%/}/$path" ;;
              esac
              skip=false
              for seen in "${seen_urls[@]:-}"; do
                if [ "$seen" = "$url" ]; then
                  skip=true
                  break
                fi
              done
              if [ "$skip" = true ]; then
                continue
              fi
              attempt_code=$(curl -sS -o /dev/null -w "%{http_code}" "$url" || echo "000")

              if echo "$ok_codes" | grep -q "\b$attempt_code\b"; then
                summary+="- [ok] $url (HTTP $attempt_code)\n"
              else
                summary+="- [miss] $url (HTTP $attempt_code)\n"
                misses+=("$url")
              fi
              record_seen "$url"
            done
          done

          {
            echo "### Debug fetch"
            echo ""
            printf "%b" "$summary"
          } >> "$GITHUB_STEP_SUMMARY"

          if [ ${#misses[@]} -gt 0 ] && [ "${DEBUG_FETCH_FAIL:-false}" = "true" ]; then
            echo "::error::Debug fetch failures: ${misses[*]}"
            exit 1
          fi

      - name: Summary
        if: steps.preflight.outputs.deploy == 'yes'
        run: |
          mode='${{ steps.deploy.outputs.mode }}'
          project='${{ steps.deploy.outputs.project }}'
          url="${{ steps.deployed_url.outputs.url || '' }}"
          probes='${{ steps.probe_urls.outputs.urls || '' }}'
          probe_status='${{ steps.verify.outputs.status || '' }}'
          failures='${{ steps.verify.outputs.failures || '' }}'
          {
            echo "### Deno Deploy"
            echo ""
            echo "- Mode: ${mode:-unknown}"
            echo "- Project: ${project}"
            if [ -n "$url" ]; then
              echo "- Primary URL: ${url}"
            fi
            if [ -n "$probe_status" ]; then
              echo "- Probe status: ${probe_status}"
            fi
            if [ -n "$probes" ]; then
              echo "- Probe URLs:"
              while IFS= read -r line; do
                line=$(echo "$line" | tr -d '\r' | xargs)
                [ -z "$line" ] && continue
                echo "  - $line"
              done <<< "$probes"
            fi
            if [ -n "$failures" ]; then
              echo "- Probe failures:"
              while IFS= read -r line; do
                line=$(echo "$line" | tr -d '\r' | xargs)
                [ -z "$line" ] && continue
                echo "  - $line"
              done <<< "$failures"
            fi
            echo "- Ref: ${GITHUB_REF##*/}"
          } >> "$GITHUB_STEP_SUMMARY"

      - name: Fail on probe failure
        if: steps.preflight.outputs.deploy == 'yes' && env.VERIFY_URL == 'true'
        run: |
          status='${{ steps.verify.outputs.status || '' }}'
          if [ "$status" != "ok" ]; then
            failures='${{ steps.verify.outputs.failures || '' }}'
            if [ -n "$failures" ]; then
              msg="${failures//$'\n'/, }"
              echo "::error::Deployment probe failed: ${msg}"
            else
              echo "::error::Deployment probe failed (see HTTP probe section)"
            fi
            exit 1
          fi
